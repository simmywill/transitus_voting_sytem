{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Voting Session</title>
  <meta name="csrf-token" content="{{ csrf_token_value|default:csrf_token }}">
  <link href="{% static 'style.css' %}?v={% now 'U' %}" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <!-- Page-local layout for uniform tiles & segments -->
  <style>
    /* ===== Segment grid: 3 columns (wide), 2 (medium), 1 (small) ===== */
    .view-session-grid {
      display: grid;
      /* Use two columns on large screens to widen segments/candidate tiles */
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 1400px) { .view-session-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 900px)  { .view-session-grid { grid-template-columns: 1fr; } }
    /* ===== Each segment body contains a scroll wrapper around the grid ===== */
    .view-session-card__body {
      display: flex;
      flex-direction: column;
      /* JS sets a uniform min-height based on one-row measurement */
      min-height: 260px; /* fallback */
    }
    /* This wrapper controls scrolling (grid itself allows overflow for menus) */
    .view-session-candidate-scroll {
      position: relative;
      overflow-y: hidden;  /* JS toggles to auto if > 3 tiles */
      overflow-x: visible;
    }
    /* ===== Candidate grid inside segment: exactly 3 columns ===== */
    .view-session-candidate-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      padding: 6px 4px 8px;
      overflow: visible; /* keep menus unclipped; wrapper controls scroll */
    }
    @media (max-width: 520px) {
      .view-session-candidate-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    /* ===== Tile: shared base for candidates & add-tile ===== */
    .tile {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.06);
      border-radius: 12px;
      background: #fff;
      box-sizing: border-box;
      min-width: 0;
    }
    /* Candidate tile specifics */
    .view-session-candidate.tile {}
    /* Kebab menu button */
    .view-session-candidate__menu-toggle {
      position: absolute;
      top: 6px; right: 6px;
      background: transparent; border: 0; cursor: pointer;
      padding: 6px; border-radius: 8px; line-height: 0;
      z-index: 2;
    }
    .view-session-candidate__menu-toggle:hover { background: rgba(0,0,0,.06); }
    /* Candidate menu: fixed to viewport so it's never clipped */
    .view-session-candidate__menu {
      position: fixed;     /* << key change */
      top: 0; left: 0;     /* JS will set exact position */
      background: #fff;
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      min-width: 180px;
      padding: 6px 0;
      display: none;       /* toggled via .is-open */
      z-index: 12000;
    }
    .view-session-candidate__menu.is-open { display: block; }
    .view-session-candidate__menu-item {
      width: 100%;
      display: flex; align-items: center; gap: 8px;
      padding: 8px 12px;
      background: transparent; border: 0; cursor: pointer; text-align: left;
      font-size: 14px;
    }
    .view-session-candidate__menu-item:hover { background: rgba(0,0,0,.06); }
    .view-session-candidate__menu-item--danger { color: #b91c1c; }
    .view-session-candidate__menu-item[data-action="change-photo"],
    .view-session-candidate__menu-item[data-action="remove-photo"] {
      color: #000;
    }
    .view-session-candidate__menu-item[data-action="change-photo"]:hover,
    .view-session-candidate__menu-item[data-action="remove-photo"]:hover {
      color: #000;
    }
    .view-session-candidate--menu-open {
      z-index: 12000 !important;
    }
    .view-session-candidate--menu-open .view-session-candidate__menu {
      z-index: 12001 !important;
    }
    .view-session-card--menu-open {
      overflow: visible;
      z-index: 9000;
    }
    /* Avatar: square, consistent */
    .avatar {
      position: relative;
      width: 100%;
      max-width: 120px;
      aspect-ratio: 1/1;
      border-radius: 12px;
      background: #f6f7f8;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.04);
      cursor: pointer; /* allow click to open file picker */
      user-select: none;
    }
    .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display: block;
      border-radius: inherit;
    }
    /* Inline SVG placeholder image */
    .avatar-placeholder-image {
      width: 100%; height: 100%; object-fit: contain; opacity: .9;
    }
    /* 18px hint line under avatar (uniform height) */
    .avatar-hint {
      height: 18px; line-height: 18px;
      font-size: 12px; color: #6b7280; text-align: center;
      user-select: none;
    }
    /* When a photo exists, keep space but hide hint text for consistent height */
    .view-session-candidate.has-photo .avatar-hint { visibility: hidden; opacity: 0; }
    .view-session-candidate.has-photo .avatar-placeholder-image { display: none !important; }
    .view-session-candidate .avatar-hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 12px;
      height: auto;
      line-height: 1.2;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      color: var(--segment-color, #0ea5e9);
      font-size: 13px;
      font-weight: 600;
      text-decoration: underline;
      box-shadow: 0 10px 24px rgba(14,165,233,.16);
    }
    /* Add-tile label: white, bold, outlined */
    .add-tile .avatar-hint {
      color: #fff;
      font-weight: 800;
      text-decoration: none;
      /* Outline the glyphs for better contrast across backgrounds */
      -webkit-text-stroke: 1px rgba(14,165,233,.85);
      text-shadow:
        0 0 1px rgba(14,165,233,.85),
        0 0 2px rgba(14,165,233,.65),
        0 0 4px rgba(14,165,233,.35);
    }
    /* Name field (allow soft-wrapping into a second line) */
    .name-input {
      width: 100%; max-width: 100%;
      text-align: center;
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 8px;
      padding: 8px 10px;
      background: #fff; box-sizing: border-box;
      font-size: 15px;
      line-height: 1.2;                 /* match candidate text metrics */
      min-height: calc(2.4em + 16px);   /* 2 lines + vertical padding (8px top + 8px bottom) */
      /* allow breaking to next line naturally */
      white-space: normal;
      overflow-wrap: anywhere; /* break even on long tokens */
      word-break: break-word;
      resize: none; /* keep consistent geometry */
      position: relative; z-index: 2; /* stay interactive above any overlays */
    }
    .name-input:focus {
      outline: none; box-shadow: 0 0 0 3px rgba(14,165,233,.15);
      border-color: var(--segment-color, #0ea5e9);
    }
    .view-session-candidate__name-wrapper {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }
    /* (Reverted) Keep Add tile hint visible; spacer remains hidden input used only for height parity */
    .view-session-candidate__name-wrapper.is-active .name-input {
      border-color: var(--segment-color, #0ea5e9);
      box-shadow: 0 0 0 3px rgba(14,165,233,.15);
    }
    .view-session-candidate__name-popover {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: none;
      padding: 8px 12px;
      min-width: 100%;
      max-width: 260px;
      text-align: center;
      font-weight: 600;
      line-height: 1.35;
      color: #000;
      background: rgba(255,255,255,0.98);
      border: 2px solid var(--segment-color, #0ea5e9);
      border-radius: 10px;
      box-shadow: 0 12px 28px rgba(15,23,42,.18);
      pointer-events: none;
      white-space: normal;
      word-break: break-word;
    }
    .view-session-candidate__name-popover::before,
    .view-session-candidate__name-popover::after {
      content: '';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-style: solid;
      border-color: transparent;
    }
    .view-session-candidate__name-popover::before {
      top: 100%;
      border-width: 8px 9px 0 9px;
      border-top-color: var(--segment-color, #0ea5e9);
    }
    .view-session-candidate__name-popover::after {
      top: calc(100% - 2px);
      border-width: 8px 9px 0 9px;
      border-top-color: rgba(255,255,255,0.98);
    }
    .view-session-candidate__name-popover.is-visible { display: block; }
    /* ===== Add tile has the SAME vertical stack as a candidate ===== */
    .add-tile.tile {
      border: 1px dashed var(--segment-color, #0ea5e9);
      background: rgba(14,165,233,.06);
      color: var(--segment-color, #0ea5e9);
      cursor: pointer;
      justify-content: flex-start; /* align like candidate tiles */
      gap: 8px;
    }
    .add-avatar { display: flex; align-items: center; justify-content: center; }
    .add-avatar i { font-size: 40px; }
    /* exact-height spacer: identical geometry to .name-input but invisible */
    .add-name-spacer {
      visibility: hidden;
      pointer-events: none;
    }
    .add-tile:hover { background: rgba(14,165,233,.12); }
    /* Segment header actions */
    .view-session-card__actions { display: inline-flex; align-items: center; gap: 8px; }
    .view-session-card__expand-toggle {
      background: transparent; border: 0; cursor: pointer; padding: .4rem; border-radius: 6px; line-height: 0;
    }
    .view-session-card__expand-toggle:hover { background: rgba(0,0,0,.06); }
    .view-session-card__title-text[contenteditable="true"] {
      cursor: text;
      display: inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      border: 2px solid transparent;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .view-session-card__title-text[contenteditable="true"]:focus {
      outline: none;
      border-color: var(--segment-color, #0ea5e9);
      box-shadow: 0 0 0 3px rgba(14,165,233,.15);
      background: rgba(255,255,255,0.65);
    }
    /* Fullscreen segment */
    .view-session-card--expanded {
      position: fixed; inset: 0; z-index: 9999;
      width: 100vw; height: 100vh; margin: 0 !important;
      border-radius: 0 !important; background: transparent; box-shadow: none;
      display: flex; flex-direction: column;
    }
    .view-session-card--expanded .view-session-card__body {
      height: calc(100vh - var(--expanded-header-h, 64px));
      overflow: hidden;
      padding: 0; /* fill full viewport height without inner padding loss */
    }
    .view-session-card--expanded .view-session-candidate-scroll {
      height: 100%;
      overflow-y: auto; /* auto shows scroll only if content exceeds */
    }
    /* Center Add Photo chip within avatar when expanded */
    .view-session-card--expanded .view-session-candidate .avatar-hint {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      bottom: auto;
    }
    body.view-session--expanded { overflow: hidden; }
    /* Empty state line */
    .view-session-card__empty {
      grid-column: 1 / -1;
      text-align: center; color: #6b7280;
      margin: 6px 0 2px;
    }
    /* Top bar containing breadcrumbs (left) and Add Segment (right) */
    .view-session-topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 0 20px; /* align horizontally with breadcrumb spacing */
      flex-wrap: wrap;
    }
    .view-session-topbar .breadcrumb { margin: 20px 0; }
    .breadcrumb__button--add-segment { white-space: nowrap; }
  </style>
</head>
<body class="view-session-body">
  <script>
    window.csrfToken = "{{ csrf_token_value|default:csrf_token|escapejs }}";
  </script>
  <nav class="voting_session-navbar">
    <div class="voting_session-navbar-content">
      <h1 class="voting_session-navbar-title">{{ session.title }}</h1>
      <div class="voting_session-navbar-toggle" onclick="toggleNavbar()">
        <span></span><span></span><span></span>
      </div>
      <div class="voting_session-navbar-links">
        <ul>
          <li><a href="{% url 'list_voting_sessions' %}">List Sessions</a></li>
          <li><a href="{% url 'voter_list' session.session_id %}">Manage Voters</a></li>
        </ul>
      </div>
    </div>
  </nav>
  <div class="view-session-wrapper">
    <div class="view-session-topbar">
      <nav class="breadcrumb">
        <a class="breadcrumb__button breadcrumb__button--home" href="{% url 'list_voting_sessions' %}">
          <span class="breadcrumb__icon"><i class="fas fa-arrow-left"></i></span>
          <span class="breadcrumb__label">Home</span>
        </a>
        <a class="breadcrumb__button breadcrumb__button--voters" href="{% url 'voter_list' session.session_id %}">
          <span class="breadcrumb__label">Add Voters</span>
          <span class="breadcrumb__icon"><i class="fas fa-arrow-right"></i></span>
        </a>
      </nav>
      <a href="#" id="add-segment-btn" class="breadcrumb__button breadcrumb__button--add-segment" title="Add Segment">
        <span class="breadcrumb__icon"><i class="fas fa-plus-circle"></i></span>
        <span class="breadcrumb__label">Add Segment</span>
      </a>
    </div>
    <div class="view-session-content">
      <div id="sortable-segments" class="view-session-grid">
        {% for segment in segments %}
        <section class="view-session-card" data-id="{{ segment.id }}">
          <header class="view-session-card__header">
            <div class="view-session-card__title">
              <span class="view-session-card__title-text"
                    contenteditable="true"
                    data-original-value="{{ segment.name }}"
                    role="textbox"
                    aria-label="Segment name"
                    spellcheck="false"
                    tabindex="0">{{ segment.name }}</span>
            </div>
            <div class="view-session-card__actions">
              <button type="button" class="view-session-card__expand-toggle" title="Maximize" aria-pressed="false">
                <i class="fas fa-expand"></i>
              </button>
              <button type="button" class="view-session-card__menu-toggle no-drag" aria-haspopup="true" aria-expanded="false">
                <i class="fas fa-ellipsis-h"></i>
              </button>
              <div class="view-session-card__menu" role="menu" draggable="false">
                <button type="button" class="view-session-card__menu-item view-session-card__menu-item--danger"
                        data-action="delete-segment" data-segment-id="{{ segment.id }}" draggable="false">
                  <i class="fas fa-trash-alt"></i> Delete Segment
                </button>
              </div>
            </div>
          </header>
          <div class="view-session-card__body">
            <div class="view-session-candidate-scroll">
              <div class="view-session-candidate-grid">
                <!-- Add tile is part of the 3 visible tiles; now same vertical stack as candidates -->
                <button type="button" class="tile add-tile view-session-add-candidate" data-segment-id="{{ segment.id }}">
                  <div class="avatar add-avatar"><i class="fas fa-plus"></i></div>
                  <div class="avatar-hint">Add Candidate</div>
                  <!-- spacer to match candidate name input height -->
                  <input class="name-input view-session-candidate__name add-name-spacer" type="text" disabled aria-hidden="true" tabindex="-1">
                </button>
                {% for candidate in segment.candidates.all %}
                <article class="view-session-candidate tile {% if candidate.photo %}has-photo{% endif %}" data-candidate-id="{{ candidate.id }}">
                  <button type="button" class="view-session-candidate__menu-toggle" aria-haspopup="true" aria-expanded="false">
                    <i class="fas fa-ellipsis-v"></i>
                  </button>
                  <div class="view-session-candidate__menu" role="menu">
                    <button type="button" class="view-session-candidate__menu-item" data-action="change-photo">
                      <i class="far fa-image"></i> Change Photo
                    </button>
                    <button type="button" class="view-session-candidate__menu-item" data-action="remove-photo">
                      <i class="fas fa-ban"></i> Delete Photo
                    </button>
                    <button type="button" class="view-session-candidate__menu-item view-session-candidate__menu-item--danger" data-action="delete-candidate">
                      <i class="fas fa-user-times"></i> Delete Candidate
                    </button>
                  </div>
                  <input type="file" class="view-session-candidate__file-input" accept="image/*" hidden>
                  <div class="avatar">
                    {% if candidate.photo %}
                      <img src="{{ candidate.photo.url }}" alt="{{ candidate.name }}" class="view-session-candidate__avatar-image">
                      <img class="avatar-placeholder-image" hidden
                           src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
                    {% else %}
                      <img src="" alt="" class="view-session-candidate__avatar-image" hidden>
                      <img class="avatar-placeholder-image"
                           src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
                    {% endif %}
                    <div class="avatar-hint">Add Photo</div>
                  </div>
                  <div class="view-session-candidate__name-wrapper">
                    {% if candidate.name == "Candidate Name" %}
                      <textarea class="name-input view-session-candidate__name"
                                rows="2"
                                placeholder="Candidate&#10;Name"
                                data-original-value="Candidate Name"
                                title="Candidate Name"></textarea>
                    {% else %}
                      <textarea class="name-input view-session-candidate__name"
                                rows="2"
                                placeholder="Candidate&#10;Name"
                                data-original-value="{{ candidate.name }}"
                                title="{{ candidate.name }}">{{ candidate.name }}</textarea>
                    {% endif %}
                    <div class="view-session-candidate__name-popover" aria-hidden="true"></div>
                  </div>
                </article>
                {% empty %}
                  <p class="view-session-card__empty">No candidates added yet.</p>
                {% endfor %}
              </div>
            </div>
          </div>
        </section>
        {% endfor %}
      </div>
    </div>
  </div>
  <div id="segment-delete-card" class="delete-confirm-card" aria-hidden="true">
    <div class="delete-confirm-card__content">
      <p id="segment-delete-message"></p>
      <div class="delete-confirm-card__actions">
        <button type="button" id="segment-delete-confirm" class="delete-card-confirm">Delete</button>
        <button type="button" id="segment-delete-cancel" class="delete-card-cancel">Cancel</button>
      </div>
    </div>
  </div>
  <!-- Candidate template -->
  <template id="view-session-candidate-template">
    <article class="view-session-candidate tile" data-candidate-id="">
      <button type="button" class="view-session-candidate__menu-toggle" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-ellipsis-v"></i>
      </button>
      <div class="view-session-candidate__menu" role="menu">
        <button type="button" class="view-session-candidate__menu-item" data-action="change-photo">
          <i class="far fa-image"></i> Change Photo
        </button>
        <button type="button" class="view-session-candidate__menu-item" data-action="remove-photo">
          <i class="fas fa-ban"></i> Delete Photo
        </button>
        <button type="button" class="view-session-candidate__menu-item view-session-candidate__menu-item--danger" data-action="delete-candidate">
          <i class="fas fa-user-times"></i> Delete Candidate
        </button>
      </div>
      <input type="file" class="view-session-candidate__file-input" accept="image/*" hidden>
      <div class="avatar">
        <img src="" alt="" class="view-session-candidate__avatar-image" hidden>
        <img class="avatar-placeholder-image"
             src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
        <div class="avatar-hint">Add Photo</div>
      </div>
      <div class="view-session-candidate__name-wrapper">
        <textarea class="name-input view-session-candidate__name"
                  rows="2"
                  placeholder="Candidate&#10;Name"
                  data-original-value="Candidate Name"
                  title="Candidate Name"></textarea>
        <div class="view-session-candidate__name-popover" aria-hidden="true"></div>
      </div>
    </article>
  </template>
  <!-- Segment template -->
  <template id="view-session-segment-template">
    <section class="view-session-card" data-id="">
      <header class="view-session-card__header">
        <div class="view-session-card__title">
          <span class="view-session-card__title-text"
                contenteditable="true"
                data-original-value=""
                role="textbox"
                aria-label="Segment name"
                spellcheck="false"
                tabindex="0"></span>
        </div>
        <div class="view-session-card__actions">
          <button type="button" class="view-session-card__expand-toggle" title="Maximize" aria-pressed="false">
            <i class="fas fa-expand"></i>
          </button>
          <button type="button" class="view-session-card__menu-toggle no-drag" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-ellipsis-h"></i>
          </button>
          <div class="view-session-card__menu" role="menu">
            <button type="button" class="view-session-card__menu-item view-session-card__menu-item--danger"
                    data-action="delete-segment" data-segment-id="" draggable="false">
              <i class="fas fa-trash-alt"></i> Delete Segment
            </button>
          </div>
        </div>
      </header>
      <div class="view-session-card__body">
        <div class="view-session-candidate-scroll">
          <div class="view-session-candidate-grid">
            <!-- Add tile first: same stack as candidate -->
            <button type="button" class="tile add-tile view-session-add-candidate" data-segment-id="">
              <div class="avatar add-avatar"><i class="fas fa-plus"></i></div>
              <div class="avatar-hint">Add Candidate</div>
              <input class="name-input view-session-candidate__name add-name-spacer" type="text" disabled aria-hidden="true" tabindex="-1">
            </button>
            <p class="view-session-card__empty">No candidates added yet.</p>
          </div>
        </div>
      </div>
    </section>
  </template>
  <script>
    const sessionId = '{{ session.session_id }}';
    const editSegmentUrlPattern = "{% url 'edit_segment' 0 %}";
    const createSegmentUrl = `/sessions/${sessionId}/segments/`;
    const updateSegmentNameUrl = (id) => `/segment/${id}/name/`;
    const resolveCsrfToken = () => {
      const meta = document.querySelector('meta[name="csrf-token"]');
      if (meta && meta.content && meta.content !== 'NOTPROVIDED') {
        return meta.content;
      }
      const inlineInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
      if (inlineInput && inlineInput.value) {
        return inlineInput.value;
      }
      if (window.csrfToken && window.csrfToken !== 'NOTPROVIDED') {
        return window.csrfToken;
      }
      const cookieMatch = document.cookie.match(/(?:^|;)\s*csrftoken=([^;]+)/);
      return cookieMatch ? decodeURIComponent(cookieMatch[1]) : '';
    };
    let csrfToken = resolveCsrfToken();
    const ensureCsrfToken = () => {
      if (!csrfToken || csrfToken === 'NOTPROVIDED') {
        csrfToken = resolveCsrfToken();
      }
      if (csrfToken && csrfToken !== 'NOTPROVIDED') {
        window.csrfToken = csrfToken;
      }
      return csrfToken;
    };
    function toggleNavbar() {
      const navbar = document.querySelector('.voting_session-navbar-links');
      if (navbar) navbar.classList.toggle('active');
    }
    (function () {
      const colors = [
        { base: '#ff6b6b', light: '#ffa7a7' },
        { base: '#f97316', light: '#fbbf24' },
        { base: '#6366f1', light: '#a855f7' },
        { base: '#14b8a6', light: '#5eead4' },
        { base: '#0ea5e9', light: '#38bdf8' }
      ];
      const segmentDeleteCard = document.getElementById('segment-delete-card');
      const segmentDeleteMessage = document.getElementById('segment-delete-message');
      const segmentDeleteConfirm = document.getElementById('segment-delete-confirm');
      const segmentDeleteCancel = document.getElementById('segment-delete-cancel');
      let pendingSegmentDelete = null;
      let expandedCard = null;
      document.addEventListener('DOMContentLoaded', () => {
        applySegmentColors();
        initSortable();
        bindAddCandidateButtons();
        initializeCandidateNameFields();
        initializeSegmentTitleEditing();
        bindGlobalEvents();
        // Lock height so each segment shows exactly 1 row Ã— 3 tiles (3 total)
        lockAllGridsToOneRowUniform();
        // Recompute on resize
        let resizeTimer = null;
        window.addEventListener('resize', () => {
          if (expandedCard) {
            updateExpandedMeasurements(expandedCard);
          } else {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(lockAllGridsToOneRowUniform, 120);
          }
        });
        // Close candidate menus on scroll/resize to avoid odd anchoring
        window.addEventListener('scroll', closeAllMenus, { passive: true });
        window.addEventListener('resize', closeAllMenus);
        if (segmentDeleteConfirm) segmentDeleteConfirm.addEventListener('click', confirmSegmentDeletion);
        if (segmentDeleteCancel) segmentDeleteCancel.addEventListener('click', hideSegmentDeleteCard);
        if (segmentDeleteCard) {
          segmentDeleteCard.addEventListener('click', (e) => {
            if (e.target === segmentDeleteCard) {
              hideSegmentDeleteCard();
            }
          });
        }
      });
      /* ========== Colors & Sortable ========== */
      function applySegmentColors() {
        document.querySelectorAll('.view-session-card').forEach(segment => {
          const segmentId = parseInt(segment.dataset.id, 10);
          if (Number.isNaN(segmentId)) return;
          const color = colors[segmentId % colors.length];
          segment.style.setProperty('--segment-color', color.base);
          segment.style.setProperty('--segment-light-color', color.light);
        });
      }
      function initSortable() {
        const container = document.getElementById('sortable-segments');
        if (!container) return;
        new Sortable(container, {
          animation: 200,
          forceFallback: true,
          filter: '.view-session-card__actions, .view-session-card__menu, .view-session-card__menu *, .view-session-card__menu-toggle, .view-session-card__menu-item, .no-drag',
          preventOnFilter: false,
          onEnd() {
            const orderedIds = Array.from(container.querySelectorAll('.view-session-card')).map(c => c.dataset.id);
            fetch('/update-segment-order/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
              body: JSON.stringify({ order: orderedIds })
            }).catch(() => {});
          }
        });
      }
      /* ========== Events ========== */
      function bindAddCandidateButtons() {
        document.querySelectorAll('.view-session-add-candidate').forEach(button => {
          button.addEventListener('click', () => handleAddCandidate(button));
        });
      }
      function initializeCandidateNameFields(scope = document) {
        const fields = Array.from(scope.querySelectorAll('.view-session-candidate__name'));
        fields.forEach(setupCandidateNameField);
      }
      function setupCandidateNameField(field) {
        if (!field || field.dataset.nameBound === 'true') return;
        if (field.disabled) return;
        field.dataset.nameBound = 'true';
        // Auto-grow textarea height to fit content lines
        const autosize = (el) => {
          try {
            el.style.height = 'auto';
            el.style.overflowY = 'hidden';
            const cs = getComputedStyle(el);
            const lineH = parseFloat(cs.lineHeight) || 18;
            const pTop = parseFloat(cs.paddingTop) || 0;
            const pBot = parseFloat(cs.paddingBottom) || 0;
            const minH = Math.round(lineH * 2 + pTop + pBot); // ensure 2-line placeholder visible
            const target = Math.max(el.scrollHeight || el.clientHeight || 0, minH);
            el.style.height = target + 'px';
          } catch (_) {}
        };
        // Initialize size
        autosize(field);
        updateCandidateNameMeta(field);
        field.addEventListener('focus', () => {
          showCandidateNamePopover(field);
        });
        field.addEventListener('blur', () => {
          hideCandidateNamePopover(field);
        });
        field.addEventListener('input', () => {
          updateCandidateNameMeta(field);
          autosize(field);
          if (document.activeElement === field) {
            showCandidateNamePopover(field);
          }
          // Recompute row heights when name wraps
          requestAnimationFrame(() => {
            try { lockAllGridsToOneRowUniform(); } catch (_) {}
          });
        });
      }
      function updateCandidateNameMeta(field) {
        if (!field) return;
        const text = (field.value || '').trim();
        const visibleText = text || field.placeholder || '';
        field.title = visibleText;
        const popover = getCandidateNamePopover(field);
        if (popover && popover.classList.contains('is-visible')) {
          popover.textContent = visibleText;
        }
      }
      function getCandidateNameWrapper(field) {
        return field?.closest('.view-session-candidate__name-wrapper') || null;
      }
      function getCandidateNamePopover(field) {
        const wrapper = getCandidateNameWrapper(field);
        return wrapper ? wrapper.querySelector('.view-session-candidate__name-popover') : null;
      }
      function showCandidateNamePopover(field) {
        const wrapper = getCandidateNameWrapper(field);
        const popover = getCandidateNamePopover(field);
        if (!wrapper || !popover) return;
        const text = (field.value || '').trim() || field.placeholder || '';
        popover.textContent = text;
        popover.classList.add('is-visible');
        wrapper.classList.add('is-active');
      }
      function hideCandidateNamePopover(field) {
        const wrapper = getCandidateNameWrapper(field);
        const popover = getCandidateNamePopover(field);
        if (!wrapper || !popover) return;
        popover.classList.remove('is-visible');
        wrapper.classList.remove('is-active');
      }
      function bindGlobalEvents() {
        document.addEventListener('click', handleDocumentClick);
        document.addEventListener('pointerout', handleCandidatePointerOut, true);
        document.addEventListener('input', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input) {
            updateCandidateInitial(input.closest('.view-session-candidate'));
          }
        });
        document.addEventListener('keydown', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input && e.key === 'Enter') { e.preventDefault(); input.blur(); }
          if (e.key === 'Escape' && pendingSegmentDelete) {
            hideSegmentDeleteCard();
          }
        });
        document.addEventListener('blur', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input) handleNameUpdate(input);
        }, true);
        document.addEventListener('change', e => {
          const fileInput = e.target.closest('.view-session-candidate__file-input');
          if (fileInput) handlePhotoUpload(fileInput);
        });
        // Click avatar/placeholder to open file chooser
        document.addEventListener('click', e => {
          const avatar = e.target.closest('.view-session-candidate .avatar');
          if (!avatar) return;
          const tile = avatar.closest('.view-session-candidate');
          if (!tile) return;
          // avoid when clicking kebab itself
          if (e.target.closest('.view-session-candidate__menu-toggle')) return;
          const fileInput = tile.querySelector('.view-session-candidate__file-input');
          if (fileInput) fileInput.click();
        });
      }
      function showSegmentDeleteCard(segmentId, segmentName, segmentCard) {
        pendingSegmentDelete = { segmentId, segmentCard };
        if (segmentDeleteMessage) {
          segmentDeleteMessage.textContent = `Are you sure you want to delete the "${segmentName}" segment? All candidates will be deleted with it.`;
        }
        if (segmentDeleteCard) {
          segmentDeleteCard.classList.add('is-visible');
          segmentDeleteCard.setAttribute('aria-hidden', 'false');
          if (segmentDeleteConfirm) {
            segmentDeleteConfirm.focus();
          }
        }
      }
      function hideSegmentDeleteCard() {
        pendingSegmentDelete = null;
        if (segmentDeleteCard) {
          segmentDeleteCard.classList.remove('is-visible');
          segmentDeleteCard.setAttribute('aria-hidden', 'true');
        }
      }
      async function confirmSegmentDeletion() {
        if (!pendingSegmentDelete || !pendingSegmentDelete.segmentId) {
          hideSegmentDeleteCard();
          return;
        }
        const { segmentId, segmentCard } = pendingSegmentDelete;
        const success = await deleteSegment(segmentId, segmentCard);
        if (success) {
          hideSegmentDeleteCard();
        }
      }
      function handleDocumentClick(event) {
        // Expand/Collapse
        const expandToggle = event.target.closest('.view-session-card__expand-toggle');
        if (expandToggle) { event.preventDefault(); toggleExpand(expandToggle); return; }
        // Candidate actions (menu items)
        const candidateAction = event.target.closest('.view-session-candidate__menu-item');
        if (candidateAction) {
          event.preventDefault();
          const candidate = candidateAction.closest('.view-session-candidate');
          if (candidate) handleCandidateAction(candidateAction.dataset.action, candidate);
          return;
        }
        // Delete segment
        const deleteSegmentBtn = event.target.closest('[data-action="delete-segment"]');
        if (deleteSegmentBtn) {
          event.preventDefault();
          const segmentId = deleteSegmentBtn.dataset.segmentId;
          const segmentCard = deleteSegmentBtn.closest('.view-session-card');
          const titleEl = segmentCard ? segmentCard.querySelector('.view-session-card__title-text') : null;
          const segmentName = (titleEl && titleEl.textContent ? titleEl.textContent.trim() : '') || 'this segment';
          if (segmentId) {
            showSegmentDeleteCard(segmentId, segmentName, segmentCard);
          }
          closeAllMenus();
          return;
        }
        // Candidate menu toggle
        const candidateToggle = event.target.closest('.view-session-candidate__menu-toggle');
        if (candidateToggle) {
          event.preventDefault(); event.stopPropagation();
          toggleMenu(candidateToggle.nextElementSibling, candidateToggle);
          return;
        }
        // Segment kebab (if you have a segment-level menu in your base CSS)
        const segmentToggle = event.target.closest('.view-session-card__menu-toggle');
        if (segmentToggle) {
          event.preventDefault(); event.stopPropagation();
          toggleMenu(segmentToggle.nextElementSibling, segmentToggle);
          return;
        }
        // Clicked elsewhere => close menus
        if (!event.target.closest('.view-session-card__menu') && !event.target.closest('.view-session-candidate__menu')) {
          closeAllMenus();
        }
      }
      // Position menu in viewport relative to its toggle (and flip if needed)
      function toggleMenu(menu, toggle) {
        if (!menu) return;
        const willOpen = !menu.classList.contains('is-open');
        closeAllMenus();
        if (!willOpen) return;
        // Make it measurable to compute width/height
        menu.style.visibility = 'hidden';
        menu.style.display = 'block';
        const rect   = toggle.getBoundingClientRect();
        const width  = menu.offsetWidth  || 200;
        const height = menu.offsetHeight || 140;
        const isSegmentMenu = menu.classList.contains('view-session-card__menu');
        let top;
        let left;
        if (isSegmentMenu) {
          const actions = toggle.closest('.view-session-card__actions');
          const actionsRect = actions ? actions.getBoundingClientRect() : { top: 0, left: 0, bottom: 0, right: 0 };
          // Position relative to the actions container to avoid transform quirks
          top = rect.bottom - actionsRect.top + 6;
          left = rect.right - actionsRect.left - width;
          // Clamp to actions container width if needed
          if (left < 0) left = 0;
        } else {
          // Candidate menu: viewport positioning
          top  = rect.bottom + 6;
          left = rect.right - width;
          if (left < 8) left = 8;
          if (top + height > window.innerHeight - 8) {
            top = Math.max(8, rect.top - 6 - height);
          }
        }
        // Apply & show
        menu.style.left = `${left}px`;
        menu.style.top  = `${top}px`;
        menu.classList.add('is-open');
        menu.style.visibility = 'visible';
        const card = toggle.closest('.view-session-card');
        if (card) {
          card.classList.add('view-session-card--menu-open');
        }
        const candidate = toggle.closest('.view-session-candidate');
        if (candidate) {
          candidate.classList.add('view-session-candidate--menu-open');
        }
        if (toggle) toggle.setAttribute('aria-expanded', 'true');
      }
      function closeCandidateMenu(menu) {
        if (!menu) return;
        menu.classList.remove('is-open');
        const toggle = menu.previousElementSibling;
        if (toggle) toggle.setAttribute('aria-expanded', 'false');
        const candidateEl = menu.closest('.view-session-candidate');
        if (candidateEl) {
          candidateEl.classList.remove('view-session-candidate--menu-open');
        }
        const cardEl = menu.closest('.view-session-card');
        if (cardEl && !cardEl.querySelector('.view-session-candidate__menu.is-open')) {
          cardEl.classList.remove('view-session-card--menu-open');
        }
        // reset transient styles
        menu.style.display = '';
        menu.style.visibility = '';
        menu.style.left = '';
        menu.style.top = '';
      }
      function closeAllMenus() {
        document.querySelectorAll('.view-session-card__menu').forEach(menu => {
          menu.classList.remove('is-open');
          const t = menu.previousElementSibling;
          if (t) t.setAttribute('aria-expanded', 'false');
          const card = menu.closest('.view-session-card');
          if (card) card.classList.remove('view-session-card--menu-open');
          menu.style.display = '';
          menu.style.visibility = '';
          menu.style.left = '';
          menu.style.top = '';
        });
        document.querySelectorAll('.view-session-candidate__menu').forEach(menu => {
          closeCandidateMenu(menu);
        });
      }
      function handleCandidatePointerOut(event) {
        const target = event.target;
        if (!target || !target.classList || !target.classList.contains('view-session-candidate')) return;
        const next = event.relatedTarget;
        if (next && target.contains(next)) return;
        const menu = target.querySelector('.view-session-candidate__menu');
        if (menu && menu.classList.contains('is-open')) {
          closeCandidateMenu(menu);
        }
      }
      /* ========== Segment inline editing ========== */
      function initializeSegmentTitleEditing(scope = document) {
        const titles = Array.from(scope.querySelectorAll('.view-session-card__title-text'));
        titles.forEach(title => {
          const card = title.closest('.view-session-card');
          const segmentId = card?.dataset?.id;
          if (!segmentId) return;
          setupSegmentTitleEditing(title, segmentId);
        });
      }
      function setupSegmentTitleEditing(titleEl, segmentId) {
        if (!titleEl || !segmentId) return;
        if (titleEl.dataset.segmentBound === 'true') return;
        titleEl.dataset.segmentBound = 'true';
        titleEl.dataset.segmentId = segmentId;
        const initialText = (titleEl.textContent || '').trim() || 'New Segment';
        titleEl.textContent = initialText;
        if (!('originalValue' in titleEl.dataset)) {
          titleEl.dataset.originalValue = initialText;
        }
        titleEl.addEventListener('focus', () => {
          requestAnimationFrame(() => {
            const selection = window.getSelection();
            if (!selection) return;
            const range = document.createRange();
            range.selectNodeContents(titleEl);
            selection.removeAllRanges();
            selection.addRange(range);
          });
        });
        titleEl.addEventListener('keydown', event => {
          if (event.key === 'Enter') {
            event.preventDefault();
            titleEl.blur();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            titleEl.textContent = titleEl.dataset.originalValue || 'New Segment';
            titleEl.blur();
          }
        });
        titleEl.addEventListener('paste', event => {
          event.preventDefault();
          const text = event.clipboardData?.getData('text/plain') || '';
          if (typeof document.execCommand === 'function') {
            document.execCommand('insertText', false, text);
          } else {
            const selection = window.getSelection();
            if (!selection) return;
            selection.deleteFromDocument();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            range.insertNode(document.createTextNode(text));
            range.collapse(false);
          }
        });
        titleEl.addEventListener('blur', () => commitSegmentTitle(titleEl));
      }
      function focusTitleForEditing(titleEl) {
        if (!titleEl) return;
        requestAnimationFrame(() => {
          titleEl.focus();
          const selection = window.getSelection();
          if (!selection) return;
          const range = document.createRange();
          range.selectNodeContents(titleEl);
          selection.removeAllRanges();
          selection.addRange(range);
        });
      }
      async function commitSegmentTitle(titleEl) {
        if (!titleEl || titleEl.dataset.saving === 'true') return;
        const segmentId = titleEl.dataset.segmentId;
        if (!segmentId) return;
        const original = (titleEl.dataset.originalValue || '').trim();
        const rawValue = (titleEl.textContent || '').trim();
        const fallback = rawValue || original || 'New Segment';
        if (!rawValue) titleEl.textContent = fallback;
        if (fallback === original) return;
        titleEl.dataset.saving = 'true';
        try {
          await updateSegmentName(segmentId, fallback);
          titleEl.dataset.originalValue = fallback;
        } catch (err) {
          console.error(err);
          titleEl.textContent = original || 'New Segment';
          alert('Unable to update the segment name. Reverting.');
        } finally {
          delete titleEl.dataset.saving;
        }
      }
      /* ========== Add/Delete candidate ========== */
      async function handleAddCandidate(button) {
        const segmentId = button.dataset.segmentId;
        if (!segmentId) return;
        button.disabled = true;
        try {
          const res = await fetch(`/segments/${segmentId}/candidates/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
            body: JSON.stringify({ name: 'Candidate Name' })
          });
          if (!res.ok) throw new Error('Failed to add candidate');
          const data = await res.json();
          if (!data.success || !data.candidate) throw new Error(data.error || 'Unable to add candidate');
          const grid = button.closest('.view-session-candidate-grid');
          if (!grid) return;
          removeEmptyState(grid);
          const card = buildCandidateCard(data.candidate);
          // Insert new candidate AFTER the add tile (row becomes [ADD, C1, C2])
          grid.insertBefore(card, grid.children[1] || null);
          initializeCandidateNameFields(card);
          // Focus the new name field so typing is immediate
          const newNameField = card.querySelector('.view-session-candidate__name');
          if (newNameField) {
            try { newNameField.focus(); newNameField.select(); } catch (_) {}
          }
          card.classList.add('view-session-candidate--just-added');
          const remeasure = () => {
            if (document.body.classList.contains('view-session--expanded') && expandedCard) {
              updateExpandedMeasurements(expandedCard);
            } else {
              lockAllGridsToOneRowUniform();
            }
          };
          // Re-measure after animation completes
          card.addEventListener('animationend', (e) => {
            if (!e || e.animationName === 'view-session-candidate-pop') remeasure();
          }, { once: true });
          setTimeout(() => card.classList.remove('view-session-candidate--just-added'), 600);
          // Fallback re-measure
          setTimeout(remeasure, 620);
          remeasure();
        } catch (e) {
          console.error(e);
          alert('Unable to add a candidate right now. Please try again.');
        } finally {
          button.disabled = false;
        }
      }
      function buildCandidateCard(candidateData) {
        const template = document.getElementById('view-session-candidate-template');
        const fragment = template.content.cloneNode(true);
        const card = fragment.querySelector('.view-session-candidate');
        const nameInput = card.querySelector('.view-session-candidate__name');
        const img = card.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = card.querySelector('.avatar-placeholder-image');
        card.dataset.candidateId = candidateData.id;
        const defaultPlaceholder = 'Candidate Name';
        const candidateName = (candidateData.name || '').trim() || defaultPlaceholder;
        if (nameInput) {
          // Show placeholder if server created with default name; don't prefill value
          nameInput.placeholder = 'Candidate\nName';
          if (candidateName === defaultPlaceholder) {
            nameInput.value = '';
            nameInput.title = defaultPlaceholder;
            nameInput.dataset.originalValue = defaultPlaceholder;
          } else {
            nameInput.value = candidateName;
            nameInput.title = candidateName;
            nameInput.dataset.originalValue = candidateName;
          }
          setupCandidateNameField(nameInput);
        }
        if (candidateData.photo_url) {
          img.src = candidateData.photo_url;
          img.alt = candidateName;
          img.hidden = false;
          if (placeholderImg) placeholderImg.hidden = true;
          card.classList.add('has-photo');
        } else {
          img.hidden = true;
          img.removeAttribute('src');
          if (placeholderImg) placeholderImg.hidden = false;
          card.classList.remove('has-photo');
        }
        return card;
      }
      function handleCandidateAction(action, candidateElement) {
        const candidateId = candidateElement?.dataset?.candidateId;
        if (!candidateElement) return;
        switch (action) {
          case 'change-photo': {
            candidateElement.querySelector('.view-session-candidate__file-input')?.click();
            closeAllMenus(); break;
          }
          case 'remove-photo': {
            if (!candidateId) { resetCandidateAvatar(candidateElement); break; }
            if (confirm('Remove the photo for this candidate?')) {
              removeCandidatePhoto(candidateId, candidateElement);
            }
            closeAllMenus(); break;
          }
          case 'delete-candidate': {
            if (!candidateId) { candidateElement.remove(); break; }
            if (confirm('Delete this candidate?')) {
              deleteCandidate(candidateId, candidateElement);
            }
            closeAllMenus(); break;
          }
          default: closeAllMenus();
        }
      }
      function handlePhotoUpload(fileInput) {
        const file = fileInput.files[0]; if (!file) return;
        const candidate = fileInput.closest('.view-session-candidate'); if (!candidate) return;
        const candidateId = candidate.dataset.candidateId || null;
        uploadCandidatePhoto(candidateId, file, candidate, fileInput);
      }
      // Safely revoke a blob URL only if it is not currently used by any
      // candidate image, and never revoke if the current candidate img still
      // references it (to avoid blanking a visible preview unexpectedly).
      function safeRevokeObjectURL(url, currentImg) {
        if (!url) return;
        try {
          if (currentImg && currentImg.src === url) return;
          const othersUseIt = Array.from(document.querySelectorAll('.view-session-candidate__avatar-image'))
            .some(img => img !== currentImg && img.src === url);
          if (!othersUseIt) URL.revokeObjectURL(url);
        } catch (_) {}
      }
      async function uploadCandidatePhoto(candidateId, file, candidateElement, fileInput) {
        const formData = new FormData(); formData.append('photo', file);
        const img = candidateElement.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = candidateElement.querySelector('.avatar-placeholder-image');
        const previousPreview = candidateElement.dataset.previewObjectUrl;
        if (previousPreview) { safeRevokeObjectURL(previousPreview, img); delete candidateElement.dataset.previewObjectUrl; }
        const previewUrl = URL.createObjectURL(file);
        candidateElement.dataset.previewObjectUrl = previewUrl;
        if (img) { img.src = previewUrl; img.hidden = false; }
        if (placeholderImg) placeholderImg.hidden = true;
        candidateElement.classList.add('has-photo');
        if (!candidateId) {
          return;
        }
        try {
        const res = await fetch(`/candidate/${candidateId}/photo/`, {
          method: 'POST', headers: { 'X-CSRFToken': ensureCsrfToken() }, body: formData
          });
          if (!res.ok) throw new Error('Failed to update photo');
          const data = await res.json();
          if (data.success && data.candidate?.photo_url) {
            const nextUrl = (() => {
              try {
                const signed = new URL(data.candidate.photo_url, window.location.origin);
                signed.searchParams.set('t', Date.now().toString());
                return signed.toString();
              } catch (_) {
                const separator = data.candidate.photo_url.includes('?') ? '&' : '?';
                return `${data.candidate.photo_url}${separator}t=${Date.now()}`;
              }
            })();
            // Probe the new URL; only swap after it loads successfully
            await new Promise((resolve) => {
              const probe = new Image();
              let settled = false;
              const finish = () => { if (!settled) { settled = true; resolve(); } };
              probe.onload = () => { if (img) img.src = nextUrl; finish(); };
              probe.onerror = () => { /* keep local preview visible */ finish(); };
              probe.src = nextUrl;
            });
          }
        } catch (e) {
          console.error(e);
          alert('Could not update the photo. Please try again.');
          // Keep the local preview so the user doesn't see a blank tile.
          // They can retry; do not clear img or placeholder here.
        } finally {
          // Only revoke the preview blob if the image has switched to the
          // server URL; otherwise keep the local preview visible.
          if (img && img.src !== previewUrl) {
            safeRevokeObjectURL(previewUrl, img);
            delete candidateElement.dataset.previewObjectUrl;
          }
          fileInput.value = '';
          closeAllMenus();
        }
      }
      async function removeCandidatePhoto(candidateId, candidateElement) {
        try {
        const res = await fetch(`/candidate/${candidateId}/photo/remove/`, {
          method: 'POST', headers: { 'X-CSRFToken': ensureCsrfToken() }
          });
          if (!res.ok) throw new Error('Failed to remove photo');
          resetCandidateAvatar(candidateElement);
        } catch (e) {
          console.error(e); alert('Unable to delete the photo right now.');
        }
      }
      async function deleteCandidate(candidateId, candidateElement) {
        try {
        const res = await fetch(`/delete_candidate/${candidateId}/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() }
          });
          if (!res.ok) throw new Error('Failed to delete candidate');
          const grid = candidateElement.closest('.view-session-candidate-grid');
          candidateElement.remove();
          if (grid) {
            ensureEmptyState(grid);
            if (document.body.classList.contains('view-session--expanded') && expandedCard) {
              updateExpandedMeasurements(expandedCard);
            } else {
              lockAllGridsToOneRowUniform();
            }
          }
        } catch (e) {
          console.error(e); alert('Unable to delete the candidate right now. Please try again.');
        }
      }
      /* ========== Delete segment ========== */
      async function deleteSegment(segmentId, segmentCard) {
        if (!segmentId) return false;
        const card = segmentCard || document.querySelector(`.view-session-card[data-id="${segmentId}"]`);
        try {
          const res = await fetch(`/delete-segment/${segmentId}/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() }
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || (data && data.success === false)) {
            const message = (data && (data.error || data.detail)) ? (data.error || data.detail) : 'Failed to delete segment';
            throw new Error(message);
          }
          if (card) {
            if (card.classList.contains('view-session-card--expanded')) {
              collapseSegment(card, card.querySelector('.view-session-card__expand-toggle'));
            }
            card.remove();
            applySegmentColors();
            lockAllGridsToOneRowUniform();
          }
          return true;
        } catch (e) {
          console.error(e);
          alert((e && e.message) ? e.message : 'Unable to delete the segment right now.');
          return false;
        }
      }
      /* ========== Candidate name inline updates ========== */
      async function handleNameUpdate(input) {
        const candidateElement = input.closest('.view-session-candidate');
        if (!candidateElement) return;
        const candidateId = candidateElement.dataset.candidateId;
        const original = (input.dataset.originalValue || '').trim();
        const rawValue = input.value || '';
        const nextValue = rawValue.trim();
        if (!nextValue) {
          input.value = original;
          updateCandidateNameMeta(input);
          return;
        }
        input.value = nextValue;
        updateCandidateNameMeta(input);
        if (!candidateId || nextValue === original) {
          return;
        }
        try {
          const res = await fetch(`/candidate/${candidateId}/name/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
            body: JSON.stringify({ name: nextValue })
          });
          if (!res.ok) throw new Error('Failed to update name');
          input.dataset.originalValue = nextValue;
        } catch (e) {
          console.error(e);
          alert('Unable to update the candidate name. Reverting to the previous value.');
          input.value = original;
          updateCandidateNameMeta(input);
        }
      }
      function resetCandidateAvatar(candidateElement) {
        const img = candidateElement.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = candidateElement.querySelector('.avatar-placeholder-image');
        const previewUrl = candidateElement.dataset.previewObjectUrl;
        if (previewUrl) { safeRevokeObjectURL(previewUrl, img); delete candidateElement.dataset.previewObjectUrl; }
        if (img) { img.hidden = true; img.removeAttribute('src'); }
        if (placeholderImg) placeholderImg.hidden = false;
        candidateElement.classList.remove('has-photo');
      }
      function updateCandidateInitial(_candidateElement) {
        /* No letter placeholder anymore; keeping this as a no-op to avoid refactors. */
      }
      /* ========== Height locking: one row (3 tiles) per segment ========== */
      function lockAllGridsToOneRowUniform() {
        // Do not clamp heights while a segment is expanded.
        if (document.body.classList.contains('view-session--expanded')) return;
        const wrappers = Array.from(document.querySelectorAll('.view-session-candidate-scroll'));
        const grids = Array.from(document.querySelectorAll('.view-session-candidate-grid'));
        if (grids.length === 0) return;
        const scrollStates = new Map();
        wrappers.forEach(w => {
          scrollStates.set(w, { top: w.scrollTop || 0 });
          w.style.maxHeight = '';
          w.style.height = '';
          // Preserve w.dataset.lockedRowHeight so we don't shrink after add/delete
          w.style.overflowY = '';
        });
        document.querySelectorAll('.view-session-card__body').forEach(b => {
          b.style.minHeight = '';
        });
        let maxRowHeight = 0;
        const bodyExtra = 18;
        grids.forEach((grid, index) => {
          const wrapper = wrappers[index] || grid.closest('.view-session-candidate-scroll');
          const tiles = Array.from(grid.querySelectorAll('.tile'));
          if (!wrapper || tiles.length === 0) {
            if (wrapper) {
              wrapper.style.maxHeight = '220px';
              wrapper.style.overflowY = 'hidden';
            }
            return;
          }
          tiles.forEach(tile => {
            tile.style.minHeight = '';
            tile.style.maxHeight = '';
          });
          const tileEntries = tiles.map(tile => ({ tile, rect: tile.getBoundingClientRect() }));
          // Ignore tiles that are mid pop-in animation to avoid measuring a scaled height
          const candidateEntries = tileEntries.filter(entry =>
            entry.tile.classList.contains('view-session-candidate') &&
            !entry.tile.classList.contains('view-session-candidate--just-added')
          );
          const referenceEntry = candidateEntries.length
            ? candidateEntries.reduce((highest, entry) => entry.rect.height > highest.rect.height ? entry : highest, candidateEntries[0])
            : tileEntries[0];
          const referenceHeight = Math.round(referenceEntry.rect.height);
          const cs = getComputedStyle(grid);
          const pTop = parseFloat(cs.paddingTop) || 0;
          const pBottom = parseFloat(cs.paddingBottom) || 0;
          const rowHeight = Math.round(referenceEntry.rect.height + pTop + pBottom);
          // Avoid visible shrink by never reducing from a previously locked
          // base row height, then expose 1.25 rows visually to hint scrolling.
          const prevRaw = parseFloat(wrapper.dataset.lockedRowHeight || '0');
          const stableRaw = Math.max(rowHeight, prevRaw || 0);
          wrapper.dataset.lockedRowHeight = String(stableRaw);
          const visibleHeight = Math.round(stableRaw * 1.25);
          maxRowHeight = Math.max(maxRowHeight, visibleHeight);
          wrapper.style.maxHeight = visibleHeight + 'px';
          wrapper.style.height = visibleHeight + 'px';
          wrapper.style.overflowY = tiles.length > 3 ? 'auto' : 'hidden';
          const stableTileHeight = Math.max(
            referenceHeight,
            Math.max(0, Math.round(stableRaw - pTop - pBottom))
          );
          tileEntries.forEach(entry => {
            entry.tile.style.minHeight = stableTileHeight + 'px';
            entry.tile.style.maxHeight = stableTileHeight + 'px';
          });
        });
        if (maxRowHeight === 0) {
          wrappers.forEach(w => {
            w.style.maxHeight = '220px';
            w.style.overflowY = 'hidden';
          });
          document.querySelectorAll('.view-session-card__body').forEach(b => {
            b.style.minHeight = '260px';
          });
          return;
        }
        document.querySelectorAll('.view-session-card__body').forEach(b => {
          b.style.minHeight = (maxRowHeight + bodyExtra) + 'px';
        });
        wrappers.forEach(w => {
          const saved = scrollStates.get(w);
          if (!saved) return;
          const maxScrollable = Math.max(0, w.scrollHeight - w.clientHeight);
          const target = Math.min(saved.top, maxScrollable);
          w.scrollTop = target;
        });
      }
      /* ========== Expand / Collapse ========== */
      function toggleExpand(btn) {
        const card = btn.closest('.view-session-card');
        if (!card) return;
        document.querySelectorAll('.view-session-card--expanded').forEach(other => {
          if (other !== card) collapseSegment(other, other.querySelector('.view-session-card__expand-toggle'));
        });
        if (card.classList.contains('view-session-card--expanded')) {
          collapseSegment(card, btn);
        } else {
          expandSegment(card, btn);
        }
      }
      function expandSegment(card, btn) {
        if (expandedCard) collapseSegment(expandedCard, expandedCard.querySelector('.view-session-card__expand-toggle'));
        card.classList.add('view-session-card--expanded');
        document.body.classList.add('view-session--expanded');
        const icon = btn?.querySelector('i');
        if (btn) { btn.setAttribute('aria-pressed', 'true'); btn.setAttribute('title', 'Minimize'); }
        if (icon) { icon.classList.remove('fa-expand'); icon.classList.add('fa-compress'); }
        updateExpandedMeasurements(card);
        expandedCard = card;
      }
      function updateExpandedMeasurements(card) {
        const header = card.querySelector('.view-session-card__header');
        const scrollWrap = card.querySelector('.view-session-candidate-scroll');
        if (!header || !scrollWrap) return;
        const headerH = header.getBoundingClientRect().height;
        card.style.setProperty('--expanded-header-h', `${headerH}px`);
        scrollWrap.style.maxHeight = '';
        scrollWrap.style.minHeight = '';
        scrollWrap.style.height = '100%';
        scrollWrap.style.overflowY = 'auto';
      }
      function collapseSegment(card, btn) {
        card.classList.remove('view-session-card--expanded');
        document.body.classList.remove('view-session--expanded');
        const icon = btn?.querySelector('i');
        if (btn) { btn.setAttribute('aria-pressed', 'false'); btn.setAttribute('title', 'Maximize'); }
        if (icon) { icon.classList.remove('fa-compress'); icon.classList.add('fa-expand'); }
        lockAllGridsToOneRowUniform();
        expandedCard = null;
      }
      /* ========== Add New Segment ========== */
      document.addEventListener('DOMContentLoaded', () => {
        const addBtn = document.getElementById('add-segment-btn');
        if (addBtn) addBtn.addEventListener('click', onAddSegmentClick);
      });
      async function onAddSegmentClick(event) {
        event.preventDefault();
        const btn = event.currentTarget;
        if (btn) btn.classList.add('is-loading');
        try {
          const res = await fetch(createSegmentUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
            body: JSON.stringify({ name: '' })
          });
          if (!res.ok) throw new Error('Failed to create segment');
          const data = await res.json();
          if (!data.success || !data.segment?.id) throw new Error(data.error || 'Could not create segment');
          const card = buildEmptySegmentCard(data.segment);
          const container = document.getElementById('sortable-segments');
          if (!container) return;
          container.insertBefore(card, container.firstChild);
          applySegmentColors();
          const addCandidateBtn = card.querySelector('.view-session-add-candidate');
          if (addCandidateBtn) addCandidateBtn.addEventListener('click', () => handleAddCandidate(addCandidateBtn));
          // Persist order (optional)
          const orderedIds = Array.from(container.querySelectorAll('.view-session-card')).map(el => el.dataset.id);
          fetch('/update-segment-order/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
            body: JSON.stringify({ order: orderedIds })
          }).catch(() => {});
          lockAllGridsToOneRowUniform();
        } catch (err) {
          console.error(err);
          alert('Unable to add a new segment right now. Please try again.');
        } finally {
          if (btn) btn.classList.remove('is-loading');
        }
      }
      function buildEmptySegmentCard(segment) {
        const template = document.getElementById('view-session-segment-template');
        const fragment = template.content.cloneNode(true);
        const card = fragment.querySelector('.view-session-card');
        card.dataset.id = segment.id;
        const titleText = card.querySelector('.view-session-card__title-text');
        const rawName = (segment.name || '').trim();
        const initialName = rawName || 'New Segment';
        if (titleText) {
          titleText.textContent = initialName;
          titleText.dataset.originalValue = rawName;
          setupSegmentTitleEditing(titleText, segment.id);
          focusTitleForEditing(titleText);
        }
        setSegmentLinks(card, segment.id);
        initializeCandidateNameFields(card);
        return card;
      }
      function setSegmentLinks(card, segmentId) {
        const editLink = card.querySelector('[data-role="edit-segment-link"]');
        if (editLink && editSegmentUrlPattern) editLink.href = editSegmentUrlPattern.replace(/0(?!\d)/, String(segmentId));
        const del = card.querySelector('[data-action="delete-segment"]');
        if (del) del.dataset.segmentId = segmentId;
        const addBtn = card.querySelector('.view-session-add-candidate');
        if (addBtn) addBtn.dataset.segmentId = segmentId;
      }
      async function updateSegmentName(segmentId, name) {
        const res = await fetch(updateSegmentNameUrl(segmentId), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': ensureCsrfToken() },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error('Failed to rename segment');
        const data = await res.json().catch(() => ({}));
        if (data && data.success === false) throw new Error(data.error || 'Rename rejected');
      }
      /* Utilities: empty state */
      function removeEmptyState(grid) {
        const emptyState = grid ? grid.querySelector('.view-session-card__empty') : null;
        if (emptyState) removeEl(emptyState);
      }
      function ensureEmptyState(grid) {
        if (!grid) return;
        const hasCandidate = grid.querySelector('.view-session-candidate');
        if (!hasCandidate && !grid.querySelector('.view-session-card__empty')) {
          const p = document.createElement('p');
          p.className = 'view-session-card__empty';
          p.textContent = 'No candidates added yet.';
          grid.appendChild(p);
        }
      }
      function removeEl(el){ if (el && el.parentNode) el.parentNode.removeChild(el); }
    })();
  </script>
  <script>
    // Force reload when page is restored from back/forward cache
    window.addEventListener('pageshow', function (e) {
      const nav = (performance && performance.getEntriesByType) ? performance.getEntriesByType('navigation')[0] : null;
      const isBack = (nav && nav.type === 'back_forward');
      if (e.persisted || isBack) {
        window.location.reload();
      }
    });
  </script>
</body>
</html>
