<style>
    
    .hidden { display: none; }

    /* Arrow tips */
    .arrow_tip_container {
        position: relative;
        display: inline-flex;
        align-items: center;
    }
    .arrow_tip {
        position: absolute;
        top: -35px;
        background: #333;
        color: #fff;
        padding: 5px 10px;
        border-radius: 8px;
        font-size: 0.9rem;
        white-space: nowrap;
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.5s ease, transform 0.5s ease;
        pointer-events: none;
    }
    .arrow_tip.show {
        opacity: 1;
        transform: translateY(0);
    }

    /* Pulse effect for arrow */
    .pulse {
        animation: pulseAnim 1.2s infinite;
    }
    @keyframes pulseAnim {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
    }

    /* Swipe overlay tip */
    .swipe-overlay {
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px 15px;
        border-radius: 10px;
        font-size: 0.95rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
        z-index: 10;
    }
    .swipe-overlay.active {
        opacity: 1;
    }

    /* Swipe hand animation */
    /* Swipe hand animation */
    /* Swipe hand animation */
/* Swipe hand animation */
.swipe-hint {
    position: absolute;
    bottom: 0.0%;       /* Use percentage of container height */
    left: 50%;         /* Center horizontally */
    transform: translateX(-50%);
    font-size: clamp(2rem, 5vw, 3rem); /* Responsive size */
    opacity: 0;
    animation: swipeFade 6s ease forwards;
    z-index: 1000;
    pointer-events: none;
}

/* Hand emoji pointing finger with wider motion */
.hand {
    display: inline-block;
    animation: swipeMotion 2s infinite;
    font-size: 2.5rem; /* Adjust size */
}

/* Widened horizontal swipe */
@keyframes swipeMotion {
    0%   { transform: translateX(-50%) translateX(0); }
    25%  { transform: translateX(-50%) translateX(-30px); }
    50%  { transform: translateX(-50%) translateX(30px); }
    75%  { transform: translateX(-50%) translateX(-30px); }
    100% { transform: translateX(-50%) translateX(0); }
}

/* Fade in/out animation for hand */
@keyframes swipeFade {
    0%, 90%, 100% { opacity: 0; }
    10%, 70% { opacity: 1; }
}

    
</style>
</style>
<head>
    {% load static %}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="{% static 'style.css' %}?v={% now 'U' %}" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
</head>
<div class="voting_page_container">
    <h2 class="voting_page_header">{{ segment.name }}</h2>
    <div class="voting_instruction">
        <p>Tip: Click on a candidate to select them. Use the arrows below to move to the next section. 
        If you change your mind, simply click another candidate. When finished, press the green ‚ÄúVote‚Äù button.</p>
    </div>
    {% if segment.candidates.count > 4 %}
        <!-- Swipe overlay tip -->
        <div class="swipe-overlay" id="swipeOverlay">
            üëâ Swipe left or right to see more candidates
        </div>
       
    {% endif %}
    <div class="voting_page_candidates" id="candidatesWrapper">
        {% csrf_token %}
        {% for candidate in segment.candidates.all %}
            <div class="voting_page_candidate" 
                id="candidate-{{ candidate.id }}" 
                data-candidate-id="{{ candidate.id }}" 
                data-segment-id="{{ segment.id }}" 
                onclick="selectCandidate('{{ candidate.id }}', '{{ segment.id }}')">
                {% if candidate.photo %}
                <img src="{{ candidate.photo.url }}" alt="{{ candidate.name }}"
                     loading="lazy"
                     onerror="this.onerror=null; this.src='{% static 'placeholder.png' %}';" />
                {% else %}
                <img src="{% static 'placeholder.png' %}" alt="{{ candidate.name }}" loading="lazy" />
                {% endif %}
                <p>{{ candidate.name }}</p>
                <input type="radio" name="candidate" value="{{ candidate.id }}" class="hidden" />
                <div class="voting_page_tick">
                    <i class="bi bi-check-circle-fill"></i>
                </div>
            </div>
        {% endfor %}

        {% if segment.candidates.count > 4 %}
         <!-- Swipe hand hint -->
         <div class="swipe-hint" id="swipeHint">
            <span class="hand">‚òùÔ∏è</span>
        </div>
        {%endif%}
    </div>
    
    

    <div class="voting_page_navigation">
        {% if current_segment > 1 %}
        <div class="arrow_tip_container">
            <a href="{% url 'bbs_ballot_entry' session_uuid=session_uuid %}?segment={{ current_segment|add:-1 }}"
               class="voting_navigation_button voting_navigation_previous">
               <i class="bi bi-caret-left-fill"></i>
            </a>
            <span class="arrow_tip">Click to go back</span>
        </div>
        {% endif %}
        
        {% if current_segment < total_segments %}
        <div class="arrow_tip_container">
            <a href="{% url 'bbs_ballot_entry' session_uuid=session_uuid %}?segment={{ current_segment|add:1 }}"
               class="voting_navigation_button voting_navigation_next pulse">
               <i class="bi bi-caret-right-fill"></i>
            </a>
            <span class="arrow_tip">Click to go next</span>
        </div>
        {% else %}
        <button class="vote-button" onclick="confirmVote()">Vote</button>
        {% endif %}
    </div>
</div>
    
    
    
</div>



<script>
    const session_uuid = "{{ session_uuid }}";
    const segmentIds = JSON.parse('{{ segment_ids_json|escapejs }}');
</script>

<script>



const legacyStorageKey = "selectedVotes";
const storageKey = `selectedVotes_${session_uuid}`;
const segmentIdStrings = segmentIds.map(id => id.toString());
let selectedVotes = {};

function persistSelections() {
    try {
        localStorage.setItem(storageKey, JSON.stringify(selectedVotes));
    } catch (e) {
        // ignore quota/storage errors
    }
}

function loadSelections() {
    let raw = null;
    try {
        raw = localStorage.getItem(storageKey);
        if (!raw) {
            const legacy = localStorage.getItem(legacyStorageKey);
            if (legacy) {
                raw = legacy;
                localStorage.setItem(storageKey, legacy);
                localStorage.removeItem(legacyStorageKey);
            }
        }
        selectedVotes = raw ? JSON.parse(raw) || {} : {};
    } catch (e) {
        selectedVotes = {};
    }

    const allowed = new Set(segmentIdStrings);
    let mutated = false;
    Object.keys(selectedVotes).forEach((segId) => {
        if (!allowed.has(segId.toString())) {
            delete selectedVotes[segId];
            mutated = true;
        }
    });
    if (mutated) {
        persistSelections();
    }
}

function hasSelectionsForAllSegments() {
    return segmentIdStrings.every((segId) =>
        Object.prototype.hasOwnProperty.call(selectedVotes, segId)
    );
}

loadSelections();

function selectCandidate(candidateId, segmentId) {
    // Update the selected vote for the given segment
    selectedVotes[segmentId.toString()] = candidateId; 
    persistSelections();

    // Remove 'selected' class only for candidates in the same segment
    document.querySelectorAll(`.voting_page_candidate[data-segment-id="${segmentId}"]`)
        .forEach((el) => el.classList.remove('selected'));

    // Add the 'selected' class to the selected candidate
    const candidate = document.getElementById(`candidate-${candidateId}`);
    if (candidate) {
        candidate.classList.add('selected');
    }
}

window.onload = function() {
    loadSelections();
    // Apply the 'selected' class to previously selected candidates
    for (const [segmentId, candidateId] of Object.entries(selectedVotes)) {
        const candidateElement = document.getElementById(`candidate-${candidateId}`);
        if (candidateElement) {
            candidateElement.classList.add('selected');
        }
    }

        // Arrow tips fade in/out
    document.querySelectorAll('.arrow_tip').forEach((tip) => {
        tip.classList.add('show');
        setTimeout(() => tip.classList.remove('show'), 4000);
    });

    // Swipe instructions if overflow
    const wrapper = document.getElementById("candidatesWrapper");
    const overlay = document.getElementById("swipeOverlay");
    const handHint = document.getElementById("swipeHint");

    if (wrapper && wrapper.scrollWidth > wrapper.clientWidth) {
        if (overlay) {
            overlay.classList.add("active");
            setTimeout(() => overlay.classList.remove("active"), 3500);
        }
        if (handHint) {
            setTimeout(() => {
                handHint.style.opacity = "1";
            }, 3500);
            setTimeout(() => {
                handHint.style.opacity = "0";
            }, 9000);
        }
        wrapper.addEventListener("scroll", () => {
            if (overlay) overlay.classList.remove("active");
            if (handHint) handHint.style.opacity = "0";
        }, { once: true });
    }
};




function confirmVote() {
    // Check if all segments have selections
    if (!hasSelectionsForAllSegments()) {
        alert("Please make selections for all segments before voting.");
        return;
    }

    // Confirm before submitting
    if (confirm("Are you sure? After this, there is no turning back.")) {
        const pairs = segmentIdStrings.map((segId) => [
            parseInt(segId, 10),
            parseInt(selectedVotes[segId], 10)
        ]);
        const payload = { session_uuid: session_uuid, choices: pairs };
        fetch(`/api/cast`, {
            method: "POST",
            headers: { 
                "Content-Type": "application/json",
                "X-CSRFToken": document.querySelector('[name="csrfmiddlewaretoken"]').value
            },
            body: JSON.stringify(payload),
        }).then(async (response) => {
            const data = await response.json().catch(() => ({}));
            if (response.ok && data.ok) {
                const receipt = data.receipt || "";
                try {
                    localStorage.setItem("receiptSelections", JSON.stringify(selectedVotes));
                    localStorage.setItem("receiptCode", receipt);
                } catch (e) { /* ignore storage issues */ }
                localStorage.removeItem(storageKey);
                localStorage.removeItem(legacyStorageKey);
                window.location.href = "/thanks/" + session_uuid + "/";
            } else {
                throw new Error(data.error || "Submit failed");
            }
        }).catch((error) => { alert(error.message); });
    }
}

</script>
