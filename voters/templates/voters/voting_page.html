<style>
    
    .hidden { display: none; }

    /* Arrow tips */
    .arrow_tip_container {
        position: relative;
        display: inline-flex;
        align-items: center;
    }
    .arrow_tip {
        position: absolute;
        top: -35px;
        background: #333;
        color: #fff;
        padding: 5px 10px;
        border-radius: 8px;
        font-size: 0.9rem;
        white-space: nowrap;
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.5s ease, transform 0.5s ease;
        pointer-events: none;
    }
    .arrow_tip.show {
        opacity: 1;
        transform: translateY(0);
    }

    /* Pulse effect for arrow */
    .pulse {
        animation: pulseAnim 1.2s infinite;
    }
    @keyframes pulseAnim {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
    }

    /* Swipe overlay tip */
    .swipe-overlay {
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px 15px;
        border-radius: 10px;
        font-size: 0.95rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
        z-index: 10;
    }
    .swipe-overlay.active {
        opacity: 1;
    }

    /* Swipe hand animation */
    /* Swipe hand animation */
    /* Swipe hand animation */
/* Swipe hand animation */
.swipe-hint {
    position: absolute;
    bottom: 0.0%;       /* Use percentage of container height */
    left: 50%;         /* Center horizontally */
    transform: translateX(-50%);
    font-size: clamp(2rem, 5vw, 3rem); /* Responsive size */
    opacity: 0;
    animation: swipeFade 6s ease forwards;
    z-index: 1000;
    pointer-events: none;
}

/* Hand emoji pointing finger with wider motion */
.hand {
    display: inline-block;
    animation: swipeMotion 2s infinite;
    font-size: 2.5rem; /* Adjust size */
}

/* Widened horizontal swipe */
@keyframes swipeMotion {
    0%   { transform: translateX(-50%) translateX(0); }
    25%  { transform: translateX(-50%) translateX(-30px); }
    50%  { transform: translateX(-50%) translateX(30px); }
    75%  { transform: translateX(-50%) translateX(-30px); }
    100% { transform: translateX(-50%) translateX(0); }
}

/* Fade in/out animation for hand */
@keyframes swipeFade {
    0%, 90%, 100% { opacity: 0; }
    10%, 70% { opacity: 1; }
}

    
</style>
</style>
<head>
    {% load static %}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="{% static 'style.css' %}?v={% now 'U' %}" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
</head>
<div class="voting_page_container">
    <h2 class="voting_page_header">{{ segment.name }}</h2>
    <div class="voting_instruction">
        <p>Tip: Click on a candidate to select them. Use the arrows below to move to the next section. 
        If you change your mind, simply click another candidate. When finished, press the green ‚ÄúVote‚Äù button.</p>
    </div>
    {% if segment.candidates.count > 4 %}
        <!-- Swipe overlay tip -->
        <div class="swipe-overlay" id="swipeOverlay">
            üëâ Swipe left or right to see more candidates
        </div>
       
    {% endif %}
    <div class="voting_page_candidates" id="candidatesWrapper">
        {% csrf_token %}
        {% for candidate in segment.candidates.all %}
            <div class="voting_page_candidate" 
                id="candidate-{{ candidate.id }}" 
                data-candidate-id="{{ candidate.id }}" 
                data-segment-id="{{ segment.id }}" 
                onclick="selectCandidate('{{ candidate.id }}', '{{ segment.id }}')">
                <img src="{{ candidate.photo.url }}" alt="{{ candidate.name }}" />
                <p>{{ candidate.name }}</p>
                <input type="radio" name="candidate" value="{{ candidate.id }}" class="hidden" />
                <div class="voting_page_tick">
                    <i class="bi bi-check-circle-fill"></i>
                </div>
            </div>
        {% endfor %}

        {% if segment.candidates.count > 4 %}
         <!-- Swipe hand hint -->
         <div class="swipe-hint" id="swipeHint">
            <span class="hand">‚òùÔ∏è</span>
        </div>
        {%endif%}
    </div>
    
    

    <div class="voting_page_navigation">
        {% if current_segment > 1 %}
        <div class="arrow_tip_container">
            {% if voter_id %}
            <a href="{% url 'voter_session' session_uuid=session_uuid voter_id=voter_id%}?segment={{ current_segment|add:-1 }}" 
            {% else %}
            <a href="{% url 'bbs_ballot_entry' session_uuid=session_uuid %}?segment={{ current_segment|add:-1 }}"
            {% endif %}
               class="voting_navigation_button voting_navigation_previous">
               <i class="bi bi-caret-left-fill"></i>
            </a>
            <span class="arrow_tip">Click to go back</span>
        </div>
        {% endif %}
        
        {% if current_segment < total_segments %}
        <div class="arrow_tip_container">
            {% if voter_id %}
            <a href="{% url 'voter_session' session_uuid=session_uuid voter_id=voter_id%}?segment={{ current_segment|add:1 }}" 
            {% else %}
            <a href="{% url 'bbs_ballot_entry' session_uuid=session_uuid %}?segment={{ current_segment|add:1 }}"
            {% endif %}
               class="voting_navigation_button voting_navigation_next pulse">
               <i class="bi bi-caret-right-fill"></i>
            </a>
            <span class="arrow_tip">Click to go next</span>
        </div>
        {% else %}
        <button class="vote-button" onclick="confirmVote()">Vote</button>
        {% endif %}
    </div>
</div>
    
    
    
</div>



<script>
    const session_uuid = "{{ session_uuid }}";
    const voter_id = "{{ voter_id|default:'' }}";
    const voteData = JSON.parse('{{ segments_json|safe }}');
</script>

<script>



let selectedVotes = JSON.parse(localStorage.getItem("selectedVotes")) || {};

function selectCandidate(candidateId, segmentId) {
    // Update the selected vote for the given segment
    selectedVotes[segmentId] = candidateId; 
    localStorage.setItem("selectedVotes", JSON.stringify(selectedVotes)); 

    // Remove 'selected' class only for candidates in the same segment
    document.querySelectorAll(`.voting_page_candidate[data-segment-id="${segmentId}"]`)
        .forEach((el) => el.classList.remove('selected'));

    // Add the 'selected' class to the selected candidate
    const candidate = document.getElementById(`candidate-${candidateId}`);
    if (candidate) {
        candidate.classList.add('selected');
    }
}

window.onload = function() {
    const savedVotes = localStorage.getItem("selectedVotes");
    if (savedVotes) {
        selectedVotes = JSON.parse(savedVotes);
        // Apply the 'selected' class to previously selected candidates
        for (const [segmentId, candidateId] of Object.entries(selectedVotes)) {
            const candidateElement = document.getElementById(`candidate-${candidateId}`);
            if (candidateElement) {
                candidateElement.classList.add('selected');
            }
        }

        // Arrow tips fade in/out
    document.querySelectorAll('.arrow_tip').forEach((tip) => {
        tip.classList.add('show');
        setTimeout(() => tip.classList.remove('show'), 4000);
    });

    // Swipe instructions if overflow
    const wrapper = document.getElementById("candidatesWrapper");
    const overlay = document.getElementById("swipeOverlay");
    const handHint = document.getElementById("swipeHint");

    if (wrapper && wrapper.scrollWidth > wrapper.clientWidth) {
        if (overlay) {
            overlay.classList.add("active");
            setTimeout(() => overlay.classList.remove("active"), 3500);
        }
        if (handHint) {
            setTimeout(() => {
                handHint.style.opacity = "1";
            }, 3500);
            setTimeout(() => {
                handHint.style.opacity = "0";
            }, 9000);
        }
        wrapper.addEventListener("scroll", () => {
            if (overlay) overlay.classList.remove("active");
            if (handHint) handHint.style.opacity = "0";
        }, { once: true });
    }
};
    }




function confirmVote() {
    // Check if all segments have selections
    console.log(`Session UUID: ${session_uuid}, Voter ID: ${voter_id}`);

    if (Object.keys(selectedVotes).length < "{{ total_segments }}") {
        alert("Please make selections for all segments before voting.");
        return;
    }

    // Confirm before submitting
    if (confirm("Are you sure? After this, there is no turning back.")) {
        if (voter_id) {
            // Legacy flow (disabled when ANON handoff enabled)
            const voteData = {
                csrfmiddlewaretoken: document.querySelector('[name="csrfmiddlewaretoken"]').value,
                votes: selectedVotes,
            };
            fetch(`/submit_vote/${session_uuid}/${voter_id}/` , {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json",
                    "X-CSRFToken": document.querySelector('[name="csrfmiddlewaretoken"]').value
                },
                body: JSON.stringify(voteData),
            }).then((response) => {
                if (response.ok) {
                    alert("Your votes have been successfully submitted!");
                    localStorage.removeItem("selectedVotes");
                    document.querySelectorAll('.voting_page_candidate').forEach((candidate) => candidate.classList.remove('selected'));
                    window.location.href = "{% url 'voter_verification' session_uuid=session_uuid  %}";
                } else {
                    throw new Error("Failed to submit your votes. Please try again.");
                }
            }).catch((error) => { alert(error.message); });
        } else {
            // New anonymous BBS cast
            const pairs = Object.entries(selectedVotes).map(([seg, cand]) => [parseInt(seg), parseInt(cand)]);
            const payload = { session_uuid: session_uuid, choices: pairs };
            fetch(`/api/cast`, {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json",
                    "X-CSRFToken": document.querySelector('[name="csrfmiddlewaretoken"]').value
                },
                body: JSON.stringify(payload),
            }).then(async (response) => {
                const data = await response.json().catch(() => ({}));
                if (response.ok && data.ok) {
                    alert("Vote recorded. Receipt: " + (data.receipt || ""));
                    localStorage.removeItem("selectedVotes");
                    window.location.href = "/results/" + session_uuid + "/";
                } else {
                    throw new Error(data.error || "Submit failed");
                }
            }).catch((error) => { alert(error.message); });
        }

       

    }
}

</script>
