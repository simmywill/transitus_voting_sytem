{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Voting Session</title>
  <link href="{% static 'style.css' %}?v={% now 'U' %}" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

  <!-- Page-local layout for uniform tiles & segments -->
  <style>
    /* ===== Segment grid: 3 columns (wide), 2 (medium), 1 (small) ===== */
    .view-session-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 1400px) { .view-session-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 900px)  { .view-session-grid { grid-template-columns: 1fr; } }

    /* ===== Each segment body contains a scroll wrapper around the grid ===== */
    .view-session-card__body {
      display: flex;
      flex-direction: column;
      /* JS sets a uniform min-height based on one-row measurement */
      min-height: 260px; /* fallback */
    }

    /* This wrapper controls scrolling (grid itself allows overflow for menus) */
    .view-session-candidate-scroll {
      position: relative;
      overflow-y: hidden;  /* JS toggles to auto if > 3 tiles */
      overflow-x: visible;
    }

    /* ===== Candidate grid inside segment: exactly 3 columns ===== */
    .view-session-candidate-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      padding: 6px 4px 8px;
      overflow: visible; /* keep menus unclipped; wrapper controls scroll */
    }
    @media (max-width: 520px) {
      .view-session-candidate-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    /* ===== Tile: shared base for candidates & add-tile ===== */
    .tile {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.06);
      border-radius: 12px;
      background: #fff;
      box-sizing: border-box;
      min-width: 0;
    }

    /* Candidate tile specifics */
    .view-session-candidate.tile {}

    /* Kebab menu button */
    .view-session-candidate__menu-toggle {
      position: absolute;
      top: 6px; right: 6px;
      background: transparent; border: 0; cursor: pointer;
      padding: 6px; border-radius: 8px; line-height: 0;
      z-index: 2;
    }
    .view-session-candidate__menu-toggle:hover { background: rgba(0,0,0,.06); }

    /* Candidate menu: fixed to viewport so it's never clipped */
    .view-session-candidate__menu {
      position: fixed;     /* << key change */
      top: 0; left: 0;     /* JS will set exact position */
      background: #fff;
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      min-width: 180px;
      padding: 6px 0;
      display: none;       /* toggled via .is-open */
      z-index: 10000;
    }
    .view-session-candidate__menu.is-open { display: block; }
    .view-session-candidate__menu-item {
      width: 100%;
      display: flex; align-items: center; gap: 8px;
      padding: 8px 12px;
      background: transparent; border: 0; cursor: pointer; text-align: left;
      font-size: 14px;
    }
    .view-session-candidate__menu-item:hover { background: rgba(0,0,0,.06); }
    .view-session-candidate__menu-item--danger { color: #b91c1c; }

    /* Avatar: square, consistent */
    .avatar {
      width: 100%;
      max-width: 120px;
      aspect-ratio: 1/1;
      border-radius: 12px;
      background: #f6f7f8;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.04);
      cursor: pointer; /* allow click to open file picker */
      user-select: none;
    }
    .avatar img {
      width: 100%; height: 100%; object-fit: cover; display: block;
    }
    /* Inline SVG placeholder image */
    .avatar-placeholder-image {
      width: 100%; height: 100%; object-fit: contain; opacity: .9;
    }
    /* 18px hint line under avatar (uniform height) */
    .avatar-hint {
      height: 18px; line-height: 18px;
      font-size: 12px; color: #6b7280; text-align: center;
      user-select: none;
    }
    /* When a photo exists, keep space but hide hint text for consistent height */
    .view-session-candidate.has-photo .avatar-hint { visibility: hidden; opacity: 0; }

    /* Name field */
    .name-input {
      width: 100%; max-width: 100%;
      text-align: center;
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 8px;
      padding: 8px 10px; /* fixed to unify row heights */
      background: #fff; box-sizing: border-box;
      font-size: 15px;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .name-input:focus {
      outline: none; box-shadow: 0 0 0 3px rgba(14,165,233,.15);
      border-color: var(--segment-color, #0ea5e9);
    }

    /* ===== Add tile has the SAME vertical stack as a candidate ===== */
    .add-tile.tile {
      border: 1px dashed var(--segment-color, #0ea5e9);
      background: rgba(14,165,233,.06);
      color: var(--segment-color, #0ea5e9);
      cursor: pointer;
      justify-content: flex-start; /* align like candidate tiles */
      gap: 8px;
    }
    .add-avatar { display: flex; align-items: center; justify-content: center; }
    .add-avatar i { font-size: 40px; }
    /* exact-height spacer: identical geometry to .name-input but invisible */
    .add-name-spacer {
      visibility: hidden;
      pointer-events: none;
    }
    .add-tile:hover { background: rgba(14,165,233,.12); }

    /* Segment header actions */
    .view-session-card__actions { display: inline-flex; align-items: center; gap: 8px; }
    .view-session-card__expand-toggle {
      background: transparent; border: 0; cursor: pointer; padding: .4rem; border-radius: 6px; line-height: 0;
    }
    .view-session-card__expand-toggle:hover { background: rgba(0,0,0,.06); }

    /* Fullscreen segment */
    .view-session-card--expanded {
      position: fixed; inset: 0; z-index: 9999;
      width: 100vw; height: 100vh; margin: 0 !important;
      border-radius: 0 !important; background: #fff; box-shadow: none;
      display: flex; flex-direction: column;
    }
    .view-session-card--expanded .view-session-card__body {
      height: calc(100vh - var(--expanded-header-h, 64px) - 16px);
      overflow: hidden;
    }
    .view-session-card--expanded .view-session-candidate-scroll {
      height: 100%;
      overflow-y: auto; /* in expanded view, always scroll as needed */
    }
    body.view-session--expanded { overflow: hidden; }

    /* Empty state line */
    .view-session-card__empty {
      grid-column: 1 / -1;
      text-align: center; color: #6b7280;
      margin: 6px 0 2px;
    }
  </style>
</head>

<body class="view-session-body">
  <nav class="voting_session-navbar">
    <div class="voting_session-navbar-content">
      <h1 class="voting_session-navbar-title">{{ session.title }}</h1>
      <div class="voting_session-navbar-toggle" onclick="toggleNavbar()">
        <span></span><span></span><span></span>
      </div>
      <div class="voting_session-navbar-links">
        <ul>
          <li><a href="{% url 'list_voting_sessions' %}">List Sessions</a></li>
          <li><a href="{% url 'voter_list' session.session_id %}">Manage Voters</a></li>
          <li><a href="{% url 'manage_session' session.session_id %}">Manage Session {{ session.session_id }}</a></li>
          <li><a href="#" id="add-segment-btn"><i class="fas fa-plus-circle"></i> Add Segment</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="view-session-wrapper">
    <div class="breadcrumb">
      <div class="step"><a href="{% url 'list_voting_sessions' %}"><i class="fas fa-home"></i> Home</a></div>
      <div class="step"><a href="{% url 'add_segments' session.session_id %}"><i class="fas a-poll-h"></i> Add Candidates and Segments</a></div>
      <div class="step active"><a href="{% url 'voter_list' session.session_id %}"><i class="fas fa-poll-h"></i> Add Voters</a></div>
    </div>

    <form method="post" action="{% url 'activate_session' session.session_id %}">
      {% csrf_token %}
      <div id="sortable-segments" class="view-session-grid">
        {% for segment in segments %}
        <section class="view-session-card" data-id="{{ segment.id }}">
          <header class="view-session-card__header">
            <div class="view-session-card__title">{{ segment.name }}</div>
            <div class="view-session-card__actions">
              <button type="button" class="view-session-card__expand-toggle" title="Maximize" aria-pressed="false">
                <i class="fas fa-expand"></i>
              </button>
              <button type="button" class="view-session-card__menu-toggle" aria-haspopup="true" aria-expanded="false">
                <i class="fas fa-ellipsis-h"></i>
              </button>
              <div class="view-session-card__menu" role="menu">
                <a href="{% url 'edit_segment' segment.id %}" class="view-session-card__menu-item">
                  <i class="fas fa-pen"></i> Edit Segment
                </a>
                <button type="button" class="view-session-card__menu-item view-session-card__menu-item--danger"
                        data-action="delete-segment" data-segment-id="{{ segment.id }}">
                  <i class="fas fa-trash-alt"></i> Delete Segment
                </button>
              </div>
            </div>
          </header>

          <div class="view-session-card__body">
            <div class="view-session-candidate-scroll">
              <div class="view-session-candidate-grid">
                <!-- Add tile is part of the 3 visible tiles; now same vertical stack as candidates -->
                <button type="button" class="tile add-tile view-session-add-candidate" data-segment-id="{{ segment.id }}">
                  <div class="avatar add-avatar"><i class="fas fa-plus"></i></div>
                  <div class="avatar-hint">Add Candidate</div>
                  <!-- spacer to match candidate name input height -->
                  <input class="name-input add-name-spacer" type="text" disabled aria-hidden="true" tabindex="-1">
                </button>

                {% for candidate in segment.candidates.all %}
                <article class="view-session-candidate tile {% if candidate.photo %}has-photo{% endif %}" data-candidate-id="{{ candidate.id }}">
                  <button type="button" class="view-session-candidate__menu-toggle" aria-haspopup="true" aria-expanded="false">
                    <i class="fas fa-ellipsis-v"></i>
                  </button>

                  <div class="view-session-candidate__menu" role="menu">
                    <button type="button" class="view-session-candidate__menu-item" data-action="change-photo">
                      <i class="far fa-image"></i> Change Photo
                    </button>
                    <button type="button" class="view-session-candidate__menu-item" data-action="remove-photo">
                      <i class="fas fa-ban"></i> Delete Photo
                    </button>
                    <button type="button" class="view-session-candidate__menu-item view-session-candidate__menu-item--danger" data-action="delete-candidate">
                      <i class="fas fa-user-times"></i> Delete Candidate
                    </button>
                  </div>

                  <input type="file" class="view-session-candidate__file-input" accept="image/*" hidden>

                  <div class="avatar">
                    {% if candidate.photo %}
                      <img src="{{ candidate.photo.url }}" alt="{{ candidate.name }}" class="view-session-candidate__avatar-image">
                      <img class="avatar-placeholder-image" hidden
                           src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
                    {% else %}
                      <img src="" alt="" class="view-session-candidate__avatar-image" hidden>
                      <img class="avatar-placeholder-image"
                           src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
                    {% endif %}
                  </div>
                  <div class="avatar-hint">Add Photo</div>

                  <input class="name-input view-session-candidate__name"
                         type="text"
                         value="{{ candidate.name }}"
                         placeholder="Candidate Name"
                         data-original-value="{{ candidate.name }}">
                </article>
                {% empty %}
                  <p class="view-session-card__empty">No candidates added yet.</p>
                {% endfor %}
              </div>
            </div>
          </div>
        </section>
        {% endfor %}
      </div>

      <div class="save_button-container">
        <button class="save_voting_session" type="submit">Activate Session</button>
      </div>
    </form>
  </div>

  <!-- Candidate template -->
  <template id="view-session-candidate-template">
    <article class="view-session-candidate tile" data-candidate-id="">
      <button type="button" class="view-session-candidate__menu-toggle" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-ellipsis-v"></i>
      </button>

      <div class="view-session-candidate__menu" role="menu">
        <button type="button" class="view-session-candidate__menu-item" data-action="change-photo">
          <i class="far fa-image"></i> Change Photo
        </button>
        <button type="button" class="view-session-candidate__menu-item" data-action="remove-photo">
          <i class="fas fa-ban"></i> Delete Photo
        </button>
        <button type="button" class="view-session-candidate__menu-item view-session-candidate__menu-item--danger" data-action="delete-candidate">
          <i class="fas fa-user-times"></i> Delete Candidate
        </button>
      </div>

      <input type="file" class="view-session-candidate__file-input" accept="image/*" hidden>
      <div class="avatar">
        <img src="" alt="" class="view-session-candidate__avatar-image" hidden>
        <img class="avatar-placeholder-image"
             src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><circle cx='64' cy='40' r='24' fill='%23d1d1d1'/><path d='M16,112c0-24,24-40,48-40s48,16,48,40' fill='%23d1d1d1'/></svg>">
      </div>
      <div class="avatar-hint">Add Photo</div>

      <input class="name-input view-session-candidate__name"
             type="text"
             value="Candidate Name"
             placeholder="Candidate Name"
             data-original-value="Candidate Name">
    </article>
  </template>

  <!-- Segment template -->
  <template id="view-session-segment-template">
    <section class="view-session-card" data-id="">
      <header class="view-session-card__header">
        <div class="view-session-card__title">
          <span class="view-session-card__title-text"></span>
          <input type="text" class="view-session-segment__name-input" placeholder="Segment name" value="" hidden>
        </div>
        <div class="view-session-card__actions">
          <button type="button" class="view-session-card__expand-toggle" title="Maximize" aria-pressed="false">
            <i class="fas fa-expand"></i>
          </button>
          <button type="button" class="view-session-card__menu-toggle" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-ellipsis-h"></i>
          </button>
          <div class="view-session-card__menu" role="menu">
            <a href="#" data-role="edit-segment-link" class="view-session-card__menu-item">
              <i class="fas fa-pen"></i> Edit Segment
            </a>
            <button type="button" class="view-session-card__menu-item view-session-card__menu-item--danger"
                    data-action="delete-segment" data-segment-id="">
              <i class="fas fa-trash-alt"></i> Delete Segment
            </button>
          </div>
        </div>
      </header>

      <div class="view-session-card__body">
        <div class="view-session-candidate-scroll">
          <div class="view-session-candidate-grid">
            <!-- Add tile first: same stack as candidate -->
            <button type="button" class="tile add-tile view-session-add-candidate" data-segment-id="">
              <div class="avatar add-avatar"><i class="fas fa-plus"></i></div>
              <div class="avatar-hint">Add Candidate</div>
              <input class="name-input add-name-spacer" type="text" disabled aria-hidden="true" tabindex="-1">
            </button>
            <p class="view-session-card__empty">No candidates added yet.</p>
          </div>
        </div>
      </div>
    </section>
  </template>

  <script>
    const sessionId = '{{ session.session_id }}';
    const editSegmentUrlPattern = "{% url 'edit_segment' 0 %}";
    const createSegmentUrl = `/sessions/${sessionId}/segments/`;
    const updateSegmentNameUrl = (id) => `/segment/${id}/name/`;
    const csrfToken = '{{ csrf_token }}';

    function toggleNavbar() {
      const navbar = document.querySelector('.voting_session-navbar-links');
      if (navbar) navbar.classList.toggle('active');
    }

    (function () {
      const colors = [
        { base: '#ff6b6b', light: '#ffa7a7' },
        { base: '#f97316', light: '#fbbf24' },
        { base: '#6366f1', light: '#a855f7' },
        { base: '#14b8a6', light: '#5eead4' },
        { base: '#0ea5e9', light: '#38bdf8' }
      ];

      let expandedCard = null;

      document.addEventListener('DOMContentLoaded', () => {
        applySegmentColors();
        initSortable();
        bindAddCandidateButtons();
        bindGlobalEvents();

        // Lock height so each segment shows exactly 1 row × 3 tiles (3 total)
        lockAllGridsToOneRowUniform();

        // Recompute on resize
        let resizeTimer = null;
        window.addEventListener('resize', () => {
          if (expandedCard) {
            updateExpandedMeasurements(expandedCard);
          } else {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(lockAllGridsToOneRowUniform, 120);
          }
        });

        // Close candidate menus on scroll/resize to avoid odd anchoring
        window.addEventListener('scroll', closeAllMenus, { passive: true });
        window.addEventListener('resize', closeAllMenus);
      });

      /* ========== Colors & Sortable ========== */
      function applySegmentColors() {
        document.querySelectorAll('.view-session-card').forEach(segment => {
          const segmentId = parseInt(segment.dataset.id, 10);
          if (Number.isNaN(segmentId)) return;
          const color = colors[segmentId % colors.length];
          segment.style.setProperty('--segment-color', color.base);
          segment.style.setProperty('--segment-light-color', color.light);
        });
      }

      function initSortable() {
        const container = document.getElementById('sortable-segments');
        if (!container) return;
        new Sortable(container, {
          animation: 200,
          forceFallback: true,
          onEnd() {
            const orderedIds = Array.from(container.querySelectorAll('.view-session-card')).map(c => c.dataset.id);
            fetch('/update-segment-order/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
              body: JSON.stringify({ order: orderedIds })
            }).catch(() => {});
          }
        });
      }

      /* ========== Events ========== */
      function bindAddCandidateButtons() {
        document.querySelectorAll('.view-session-add-candidate').forEach(button => {
          button.addEventListener('click', () => handleAddCandidate(button));
        });
      }

      function bindGlobalEvents() {
        document.addEventListener('click', handleDocumentClick);
        document.addEventListener('input', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input) updateCandidateInitial(input.closest('.view-session-candidate'));
        });
        document.addEventListener('keydown', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input && e.key === 'Enter') { e.preventDefault(); input.blur(); }
        });
        document.addEventListener('blur', e => {
          const input = e.target.closest('.view-session-candidate__name');
          if (input) handleNameUpdate(input);
        }, true);
        document.addEventListener('change', e => {
          const fileInput = e.target.closest('.view-session-candidate__file-input');
          if (fileInput) handlePhotoUpload(fileInput);
        });

        // Click avatar/placeholder to open file chooser
        document.addEventListener('click', e => {
          const avatar = e.target.closest('.view-session-candidate .avatar');
          if (!avatar) return;
          const tile = avatar.closest('.view-session-candidate');
          if (!tile) return;
          // avoid when clicking kebab itself
          if (e.target.closest('.view-session-candidate__menu-toggle')) return;
          const fileInput = tile.querySelector('.view-session-candidate__file-input');
          if (fileInput) fileInput.click();
        });
      }

      function handleDocumentClick(event) {
        // Expand/Collapse
        const expandToggle = event.target.closest('.view-session-card__expand-toggle');
        if (expandToggle) { event.preventDefault(); toggleExpand(expandToggle); return; }

        // Candidate actions (menu items)
        const candidateAction = event.target.closest('.view-session-candidate__menu-item');
        if (candidateAction) {
          event.preventDefault();
          const candidate = candidateAction.closest('.view-session-candidate');
          if (candidate) handleCandidateAction(candidateAction.dataset.action, candidate);
          return;
        }

        // Delete segment
        const deleteSegmentBtn = event.target.closest('[data-action="delete-segment"]');
        if (deleteSegmentBtn) {
          event.preventDefault();
          const segmentId = deleteSegmentBtn.dataset.segmentId;
          if (segmentId && confirm('Are you sure you want to delete this segment?')) {
            deleteSegment(segmentId);
          }
          closeAllMenus();
          return;
        }

        // Candidate menu toggle
        const candidateToggle = event.target.closest('.view-session-candidate__menu-toggle');
        if (candidateToggle) {
          event.preventDefault(); event.stopPropagation();
          toggleMenu(candidateToggle.nextElementSibling, candidateToggle);
          return;
        }

        // Segment kebab (if you have a segment-level menu in your base CSS)
        const segmentToggle = event.target.closest('.view-session-card__menu-toggle');
        if (segmentToggle) {
          event.preventDefault(); event.stopPropagation();
          toggleMenu(segmentToggle.nextElementSibling, segmentToggle);
          return;
        }

        // Clicked elsewhere => close menus
        if (!event.target.closest('.view-session-card__menu') && !event.target.closest('.view-session-candidate__menu')) {
          closeAllMenus();
        }
      }

      // Position menu in viewport relative to its toggle (and flip if needed)
      function toggleMenu(menu, toggle) {
        if (!menu) return;
        const willOpen = !menu.classList.contains('is-open');
        closeAllMenus();
        if (!willOpen) return;

        // Make it measurable to compute width/height
        menu.style.visibility = 'hidden';
        menu.style.display = 'block';

        const rect   = toggle.getBoundingClientRect();
        const width  = menu.offsetWidth  || 200;
        const height = menu.offsetHeight || 140;

        // Default: below-right of toggle
        let top  = rect.bottom + 6;
        let left = rect.right - width;

        // Flip to fit viewport with small margins
        if (left < 8) left = 8;
        if (top + height > window.innerHeight - 8) {
          top = Math.max(8, rect.top - 6 - height);
        }

        // Apply & show
        menu.style.left = `${left}px`;
        menu.style.top  = `${top}px`;
        menu.classList.add('is-open');
        menu.style.visibility = 'visible';
      }

      function closeAllMenus() {
        document.querySelectorAll('.view-session-card__menu').forEach(menu => {
          menu.classList.remove('is-open');
          const t = menu.previousElementSibling; if (t) t.setAttribute('aria-expanded', 'false');
        });
        document.querySelectorAll('.view-session-candidate__menu').forEach(menu => {
          menu.classList.remove('is-open');
          const t = menu.previousElementSibling; if (t) t.setAttribute('aria-expanded', 'false');
          // reset transient styles
          menu.style.display = '';
          menu.style.visibility = '';
          menu.style.left = '';
          menu.style.top  = '';
        });
      }

      /* ========== Add/Delete candidate ========== */
      async function handleAddCandidate(button) {
        const segmentId = button.dataset.segmentId;
        if (!segmentId) return;

        button.disabled = true;
        try {
          const res = await fetch(`/segments/${segmentId}/candidates/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ name: 'Candidate Name' })
          });
          if (!res.ok) throw new Error('Failed to add candidate');
          const data = await res.json();
          if (!data.success || !data.candidate) throw new Error(data.error || 'Unable to add candidate');

          const grid = button.closest('.view-session-candidate-grid');
          if (!grid) return;

          removeEmptyState(grid);
          const card = buildCandidateCard(data.candidate);

          // Insert new candidate AFTER the add tile (row becomes [ADD, C1, C2])
          grid.insertBefore(card, grid.children[1] || null);

          card.classList.add('view-session-candidate--just-added');
          setTimeout(() => card.classList.remove('view-session-candidate--just-added'), 600);

          lockAllGridsToOneRowUniform();
        } catch (e) {
          console.error(e);
          alert('Unable to add a candidate right now. Please try again.');
        } finally {
          button.disabled = false;
        }
      }

      function buildCandidateCard(candidateData) {
        const template = document.getElementById('view-session-candidate-template');
        const fragment = template.content.cloneNode(true);
        const card = fragment.querySelector('.view-session-candidate');
        const nameInput = card.querySelector('.view-session-candidate__name');
        const img = card.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = card.querySelector('.avatar-placeholder-image');

        card.dataset.candidateId = candidateData.id;
        const candidateName = candidateData.name || 'Candidate Name';
        nameInput.value = candidateName;
        nameInput.dataset.originalValue = candidateName;

        if (candidateData.photo_url) {
          img.src = candidateData.photo_url;
          img.alt = candidateName;
          img.hidden = false;
          if (placeholderImg) placeholderImg.hidden = true;
          card.classList.add('has-photo');
        } else {
          img.hidden = true;
          img.removeAttribute('src');
          if (placeholderImg) placeholderImg.hidden = false;
          card.classList.remove('has-photo');
        }
        return card;
      }

      function handleCandidateAction(action, candidateElement) {
        const candidateId = candidateElement?.dataset?.candidateId;
        if (!candidateElement) return;

        switch (action) {
          case 'change-photo': {
            candidateElement.querySelector('.view-session-candidate__file-input')?.click();
            closeAllMenus(); break;
          }
          case 'remove-photo': {
            if (!candidateId) { resetCandidateAvatar(candidateElement); break; }
            if (confirm('Remove the photo for this candidate?')) {
              removeCandidatePhoto(candidateId, candidateElement);
            }
            closeAllMenus(); break;
          }
          case 'delete-candidate': {
            if (!candidateId) { candidateElement.remove(); break; }
            if (confirm('Delete this candidate?')) {
              deleteCandidate(candidateId, candidateElement);
            }
            closeAllMenus(); break;
          }
          default: closeAllMenus();
        }
      }

      function handlePhotoUpload(fileInput) {
        const file = fileInput.files[0]; if (!file) return;
        const candidate = fileInput.closest('.view-session-candidate'); if (!candidate) return;
        const candidateId = candidate.dataset.candidateId; if (!candidateId) return;
        uploadCandidatePhoto(candidateId, file, candidate, fileInput);
      }

      async function uploadCandidatePhoto(candidateId, file, candidateElement, fileInput) {
        const formData = new FormData(); formData.append('photo', file);
        const img = candidateElement.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = candidateElement.querySelector('.avatar-placeholder-image');
        const previewUrl = URL.createObjectURL(file);
        if (img) { img.src = previewUrl; img.hidden = false; }
        if (placeholderImg) placeholderImg.hidden = true;
        candidateElement.classList.add('has-photo');

        try {
          const res = await fetch(`/candidate/${candidateId}/photo/`, {
            method: 'POST', headers: { 'X-CSRFToken': csrfToken }, body: formData
          });
          if (!res.ok) throw new Error('Failed to update photo');
          const data = await res.json();
          if (data.success && data.candidate?.photo_url) {
            img.src = `${data.candidate.photo_url}?t=${Date.now()}`;
          }
        } catch (e) {
          console.error(e); alert('Could not update the photo. Please try again.');
          resetCandidateAvatar(candidateElement);
        } finally {
          URL.revokeObjectURL(previewUrl); fileInput.value = ''; closeAllMenus();
        }
      }

      async function removeCandidatePhoto(candidateId, candidateElement) {
        try {
          const res = await fetch(`/candidate/${candidateId}/photo/remove/`, {
            method: 'POST', headers: { 'X-CSRFToken': csrfToken }
          });
          if (!res.ok) throw new Error('Failed to remove photo');
          resetCandidateAvatar(candidateElement);
        } catch (e) {
          console.error(e); alert('Unable to delete the photo right now.');
        }
      }

      async function deleteCandidate(candidateId, candidateElement) {
        try {
          const res = await fetch(`/delete_candidate/${candidateId}/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken }
          });
          if (!res.ok) throw new Error('Failed to delete candidate');
          const grid = candidateElement.closest('.view-session-candidate-grid');
          candidateElement.remove();
          if (grid) { ensureEmptyState(grid); lockAllGridsToOneRowUniform(); }
        } catch (e) {
          console.error(e); alert('Unable to delete the candidate right now. Please try again.');
        }
      }

      /* ========== Delete segment ========== */
      async function deleteSegment(segmentId) {
        try {
          const res = await fetch(`/delete-segment/${segmentId}/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken }
          });
          if (!res.ok) throw new Error('Failed to delete segment');
          const segmentCard = document.querySelector(`.view-session-card[data-id="${segmentId}"]`);
          if (segmentCard) {
            if (segmentCard.classList.contains('view-session-card--expanded')) {
              collapseSegment(segmentCard, segmentCard.querySelector('.view-session-card__expand-toggle'));
            }
            segmentCard.remove();
            applySegmentColors();
            lockAllGridsToOneRowUniform();
          }
        } catch (e) {
          console.error(e); alert('Unable to delete the segment right now.');
        }
      }

      /* ========== Candidate name inline updates ========== */
      async function handleNameUpdate(input) {
        const candidateElement = input.closest('.view-session-candidate');
        if (!candidateElement) return;
        const candidateId = candidateElement.dataset.candidateId;
        const original = input.dataset.originalValue || '';
        const nextValue = input.value.trim();

        if (!candidateId || nextValue === original) return;
        if (!nextValue) { input.value = original; return; }

        try {
          const res = await fetch(`/candidate/${candidateId}/name/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ name: nextValue })
          });
          if (!res.ok) throw new Error('Failed to update name');
          input.dataset.originalValue = nextValue;
        } catch (e) {
          console.error(e);
          alert('Unable to update the candidate name. Reverting to the previous value.');
          input.value = original;
        }
      }

      function resetCandidateAvatar(candidateElement) {
        const img = candidateElement.querySelector('.view-session-candidate__avatar-image');
        const placeholderImg = candidateElement.querySelector('.avatar-placeholder-image');
        if (img) { img.hidden = true; img.removeAttribute('src'); }
        if (placeholderImg) placeholderImg.hidden = false;
        candidateElement.classList.remove('has-photo');
      }
      function updateCandidateInitial(_candidateElement) {
        /* No letter placeholder anymore; keeping this as a no-op to avoid refactors. */
      }

      /* ========== Height locking: one row (3 tiles) per segment ========== */
      function lockAllGridsToOneRowUniform() {
        const wrappers = Array.from(document.querySelectorAll('.view-session-candidate-scroll'));
        const grids = Array.from(document.querySelectorAll('.view-session-candidate-grid'));
        if (grids.length === 0) return;

        // Reset all first to get accurate measurements
        wrappers.forEach(w => { w.style.maxHeight = ''; w.style.height = ''; /* overflow-y toggled below */ });

        // Choose a sample grid with at least one tile
        const sample = grids.find(g => g.querySelector('.tile')) || grids[0];
        const firstTile = sample.querySelector('.tile');
        if (!firstTile) {
          // Nothing to measure; set safe fallback
          wrappers.forEach(w => { w.style.maxHeight = '220px'; w.style.overflowY = 'hidden'; });
          document.querySelectorAll('.view-session-card__body').forEach(b => { b.style.minHeight = '260px'; });
          return;
        }

        // Measure one tile height + grid paddings for a single row
        const tileRect = firstTile.getBoundingClientRect();
        const cs = getComputedStyle(sample);
        const pTop = parseFloat(cs.paddingTop) || 0;
        const pBottom = parseFloat(cs.paddingBottom) || 0;
        const oneRowHeight = Math.round(tileRect.height + pTop + pBottom);

        // Apply to all wrappers; scroll if > 3 tiles (add tile counts as one)
        grids.forEach((g, i) => {
          const w = wrappers[i] || g.closest('.view-session-candidate-scroll');
          if (!w) return;
          w.style.maxHeight = oneRowHeight + 'px';

          const tileCount = g.querySelectorAll('.tile').length; // includes add-tile
          w.style.overflowY = tileCount > 3 ? 'auto' : 'hidden';
        });

        // Make each segment body the same height as well
        const bodyExtra = 18;
        const target = oneRowHeight + bodyExtra;
        document.querySelectorAll('.view-session-card__body').forEach(b => {
          b.style.minHeight = target + 'px';
        });
      }

      /* ========== Expand / Collapse ========== */
      function toggleExpand(btn) {
        const card = btn.closest('.view-session-card');
        if (!card) return;

        document.querySelectorAll('.view-session-card--expanded').forEach(other => {
          if (other !== card) collapseSegment(other, other.querySelector('.view-session-card__expand-toggle'));
        });

        if (card.classList.contains('view-session-card--expanded')) {
          collapseSegment(card, btn);
        } else {
          expandSegment(card, btn);
        }
      }
      function expandSegment(card, btn) {
        if (expandedCard) collapseSegment(expandedCard, expandedCard.querySelector('.view-session-card__expand-toggle'));

        card.classList.add('view-session-card--expanded');
        document.body.classList.add('view-session--expanded');

        const icon = btn?.querySelector('i');
        if (btn) { btn.setAttribute('aria-pressed', 'true'); btn.setAttribute('title', 'Minimize'); }
        if (icon) { icon.classList.remove('fa-expand'); icon.classList.add('fa-compress'); }

        updateExpandedMeasurements(card);
        expandedCard = card;
      }
      function updateExpandedMeasurements(card) {
        const header = card.querySelector('.view-session-card__header');
        const scrollWrap = card.querySelector('.view-session-candidate-scroll');
        if (!header || !scrollWrap) return;
        const headerH = header.getBoundingClientRect().height;
        card.style.setProperty('--expanded-header-h', `${headerH}px`);
        scrollWrap.style.maxHeight = '';
        scrollWrap.style.height = `calc(100vh - ${headerH}px - 16px)`;
        scrollWrap.style.overflowY = 'auto';
      }
      function collapseSegment(card, btn) {
        card.classList.remove('view-session-card--expanded');
        document.body.classList.remove('view-session--expanded');

        const icon = btn?.querySelector('i');
        if (btn) { btn.setAttribute('aria-pressed', 'false'); btn.setAttribute('title', 'Maximize'); }
        if (icon) { icon.classList.remove('fa-compress'); icon.classList.add('fa-expand'); }

        lockAllGridsToOneRowUniform();
        expandedCard = null;
      }

      /* ========== Add New Segment ========== */
      document.addEventListener('DOMContentLoaded', () => {
        const addBtn = document.getElementById('add-segment-btn');
        if (addBtn) addBtn.addEventListener('click', onAddSegmentClick);
      });

      async function onAddSegmentClick(event) {
        event.preventDefault();
        const btn = event.currentTarget;
        if (btn) btn.classList.add('is-loading');

        try {
          const res = await fetch(createSegmentUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ name: '' })
          });
          if (!res.ok) throw new Error('Failed to create segment');
          const data = await res.json();
          if (!data.success || !data.segment?.id) throw new Error(data.error || 'Could not create segment');

          const card = buildEmptySegmentCard(data.segment);
          const container = document.getElementById('sortable-segments');
          if (!container) return;
          container.insertBefore(card, container.firstChild);

          applySegmentColors();

          const addCandidateBtn = card.querySelector('.view-session-add-candidate');
          if (addCandidateBtn) addCandidateBtn.addEventListener('click', () => handleAddCandidate(addCandidateBtn));

          // Persist order (optional)
          const orderedIds = Array.from(container.querySelectorAll('.view-session-card')).map(el => el.dataset.id);
          fetch('/update-segment-order/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({ order: orderedIds })
          }).catch(() => {});

          lockAllGridsToOneRowUniform();
        } catch (err) {
          console.error(err);
          alert('Unable to add a new segment right now. Please try again.');
        } finally {
          if (btn) btn.classList.remove('is-loading');
        }
      }

      function buildEmptySegmentCard(segment) {
        const template = document.getElementById('view-session-segment-template');
        const fragment = template.content.cloneNode(true);
        const card = fragment.querySelector('.view-session-card');
        card.dataset.id = segment.id;

        const titleText = card.querySelector('.view-session-card__title-text');
        const nameInput = card.querySelector('.view-session-segment__name-input');
        const initialName = segment.name || '';
        if (titleText) titleText.textContent = initialName || 'New Segment';
        if (nameInput) {
          nameInput.value = initialName; nameInput.hidden = false; nameInput.dataset.originalValue = initialName;
          nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); nameInput.blur(); }});
          nameInput.addEventListener('blur', async () => {
            const nextValue = nameInput.value.trim();
            const original = nameInput.dataset.originalValue || '';
            const valueToSave = nextValue || (original || 'New Segment');
            try {
              await updateSegmentName(segment.id, valueToSave);
              nameInput.dataset.originalValue = valueToSave;
              if (titleText) titleText.textContent = valueToSave;
            } catch {
              nameInput.value = original;
              if (titleText) titleText.textContent = original || 'New Segment';
              alert('Unable to update the segment name. Reverting.');
            } finally { nameInput.hidden = true; }
          });
          setTimeout(() => nameInput.focus(), 0);
        }

        setSegmentLinks(card, segment.id);

        const expandBtn = card.querySelector('.view-session-card__expand-toggle');
        if (expandBtn) expandBtn.addEventListener('click', (e) => { e.preventDefault(); toggleExpand(expandBtn); });

        return card;
      }

      function setSegmentLinks(card, segmentId) {
        const editLink = card.querySelector('[data-role="edit-segment-link"]');
        if (editLink && editSegmentUrlPattern) editLink.href = editSegmentUrlPattern.replace(/0(?!\d)/, String(segmentId));
        const del = card.querySelector('[data-action="delete-segment"]');
        if (del) del.dataset.segmentId = segmentId;
        const addBtn = card.querySelector('.view-session-add-candidate');
        if (addBtn) addBtn.dataset.segmentId = segmentId;
      }

      async function updateSegmentName(segmentId, name) {
        const res = await fetch(updateSegmentNameUrl(segmentId), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error('Failed to rename segment');
        const data = await res.json().catch(() => ({}));
        if (data && data.success === false) throw new Error(data.error || 'Rename rejected');
      }

      /* Utilities: empty state */
      function removeEmptyState(grid) {
        const emptyState = grid ? grid.querySelector('.view-session-card__empty') : null;
        if (emptyState) removeEl(emptyState);
      }
      function ensureEmptyState(grid) {
        if (!grid) return;
        const hasCandidate = grid.querySelector('.view-session-candidate');
        if (!hasCandidate && !grid.querySelector('.view-session-card__empty')) {
          const p = document.createElement('p');
          p.className = 'view-session-card__empty';
          p.textContent = 'No candidates added yet.';
          grid.appendChild(p);
        }
      }
      function removeEl(el){ if (el && el.parentNode) el.parentNode.removeChild(el); }

    })();
  </script>
</body>
</html>
